# 빠른 CPU를 위한 설계 기법

### 클럭

CPU는 클럭 신호에 맞춰 움직인다.

CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다.

즉, 클럭 속도가 높아지면, CPU는 명령어 사이클을 더 빠르게 반복할 것이므로, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것이다.

클럭속도는 Hz단위로 측정한다.

이는 1초에 클럭이 몇번 반복되는지 나타낸다.

Intel i7 → Base 2.5Ghz , Max 4.9Ghz

1Ghz(1,000,000,000 = 10^9) 초당 25억번 반복하고, 최대 49억번까지 반복한다.

`클럭 속도는 일정하지 않다.`

CPU는 계속 일정한 클럭속도를 유지하기보다는 고성능을 요하는 순간에는 순간적으로 클럭속도를 높이고, 그렇지 않을 때는 유연하게 클럭속도를 낮추기도 한다.

하지만 발열 문제 때문에, 클럭 속도만으로 CPU의 성능을 올리는것에는 한계가 있다.

### 코어와 멀티코어

![Untitled](https://user-images.githubusercontent.com/70310271/210173707-b8c31de6-4718-4b6d-8212-61486ff1c064.png)

코어를 여러개 포함하고 있는 CPU를 “멀티코어 CPU” 또는 “멀티코어 프로세서”라고 부른다.

코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산속도가 증가하지는 않는다.

즉, 중요한것은 코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐이다.

### 스레드와 멀티스레드

Thread의 사전적의미는 “실행 흐름의 단위”이다.

하지만 CPU에서 사용되는 쓰레드와 프로그래밍에서 사용되는 쓰레드는 용례가 다르다.

쓰레드에는 CPU에서 사용되는 하드웨어적 쓰레드가 있고, 프로그램에서 사용되는 소프트웨어적 쓰레드가 있다.

- 하드웨어적 쓰레드

![Untitled 1](https://user-images.githubusercontent.com/70310271/210173715-03ff9682-adf4-4b07-928f-4226ce5fa5af.png)

스레드를 하드웨어적으로 정의하면 “하나의 코어가 동시에 처리하는 명령어 단위”를 의미한다.

지금 까지 배운 CPU는 1코어 1쓰레드 CPU이다.

즉, 명령어를 실행하는 부품이 하나있고, 한 번에 하나씩 명령어를 실행하는 CPU를 가정했다.

반면 여러 쓰레드를 지원하는 CPU는 하나의 코어로도 여러개의 명령어를 동시에 실행할 수 있다.

하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 “멀티쓰레드 프로세서” 또는 “멀티쓰레드 CPU”라고한다.

만약 8코어 16쓰레드면, 명령어를 실행하는 부품을 여덟 개 포함하고, 한번에 열여섯개의 명령어를 처리할 수 있는 CPU를 의미한다.

멀티쓰레드와 함꼐 자주 접할 용어로 하이퍼 쓰레딩이 있다.

이는 인텔의 멀티쓰레드 기술을 의미한다.

인텔이 자신들의 멀티스레드 기술에 하이퍼스레딩이라는 명칭을 부여한것이다.

- 소프트웨어적 쓰레드

소프트웨어적으로 정의된 쓰레드는 “하나의 프로그램에서 독립적으로 실행되는 단위”이다.

운영체제에서 말하는 쓰레드는 보통 소프트웨어적으로 정의된 쓰레드를 의미한다.

하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있다.

![Untitled 2](https://user-images.githubusercontent.com/70310271/210173716-ee24a0b3-85fd-41ec-aab1-97259346f88a.png)

ex) 워드 프로세서 프로그램을 개발한다고 가정해보자.

1. 사용자로부터 입력받은 내용을 화면에 보여주는 기능
2. 사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능
3. 사용자가 입력한 내용을 수시로 저장하는 기능

이 기능들을 작동시키는 코드를 각각의 쓰레드로 만들면 동시에 실행할 수 있다.

![Untitled 3](https://user-images.githubusercontent.com/70310271/210173719-411f3db2-c7b1-4ad8-93c5-b9176b1e5f9e.png)

한 번에 하나씩 명령어를 처리하는 1코어 1쓰레드 CPU도 소프트웨어적 쓰레드를 수십개 실행할 수 있다.

`1코어 1쓰레드 CPU로도 프로그램의 여러부분을 동시에 실행할 수 있다.`

만약 쓰레드의 사전적 정의만을 암기한다면 이해하기 어려우므로, 하드웨어와 소프트웨어를 나눠 기억하는게 좋다.

하드웨어 쓰레드중 멀티쓰레드 프로세서에 대해 더 자세히 알아보자.

멀티쓰레드 프로세서를 실제로 설계하는 일은 매우 복잡하지만, 핵심은 레지스터에 있다.

하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 PC,SP, MAR, MBR와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 가지고 있으면 된다.

Ex) 프로그램 카운터가 2개라면, 메모리에서 가져올 명령어 주소도 두개 지정할 수 있고, 스택 포인터도 두개라면, 두개의 스택을 관리할 수 있다.

![Untitled 4](https://user-images.githubusercontent.com/70310271/210173724-3804df4b-2d9c-4cdc-a659-dee7b5a13bfc.png)

편의상 하나의 명령엍를 실행하기 위해 꼭 필요한 레지스터들을 레지스터 세트라고 표현하자. 이렇게 4개의 쓰레드라고 볼 수 있는것이다.

그러나 메모리 속 프로그램 입장에서 봤을때 하드웨어 쓰레드는 마치 “한 번에 하나의 명령어를 처리하는 CPU나 다름없다.”

프로그램 입장에서 봤을 땐 한번에 하나의 명령어를 처리하는 CPU가 4개 있는것 처럼 보인다.

그래서 하드웨어 쓰레드를 논리 프로세서(Logical Processor)라고 부르기도 한다.

![Untitled 5](https://user-images.githubusercontent.com/70310271/210173726-6010cb3f-d628-487d-9e81-509f08e3c8d6.png)

i7-8700k의 코어가 6개, 쓰레드가 12개이다.

실제 CPU속에 명령어를 처리하는 코어는 6개지만, 메모리 속 프로그램이 보기에는 한 번에 하나의 명령어를 처리하는 부품이 마치 12개 처럼 보이기 때문에 논리 프로세서가 8개로 나오는것이다.

### 명령어 병렬 처리 기법

빠른 CPU를 만들려면 높은 클럭 속도에 멀티코어, 멀티 쓰레드를 지원하는 CPU를 만드는것도 중요하지만, CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는것도 중요하다.

명령어를 동시에 처리하여 CPU를 한시도 쉬지않고 작동시키는 기법인 명령어 병렬처리 기법 (ILP : Instruction-Level Parallelism)을 알아보자.

대표적인 명령어 병렬처리 기법

- 명령어 파이프라이닝

명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 다음과 같이 나눌 수 있다.

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

feat) 전공서에 따라 (명령어 인출 → 명령어 실행) or (명령어 인출 → 명령어 해석 → 메모리 접근 → 결과저장)로 나누기도 한다.

여기서 중요한점은 같은 단계가 겹치지만 않는다면 CPU는 ‘각 단계를 동시에 실행할 수 있다.’

![Untitled 6](https://user-images.githubusercontent.com/70310271/210173728-d79181d6-23ce-42e5-9f03-f091208faf0c.png)

잘 생각해보면, 동시에 일어나지만 않으면 레지스터가 놀때마다 쓸 수 있기 때문에, 이렇게 겹쳐서 명령어를 실행하면 훨씬 더 효율적으로 처리할 수 있다.

이처럼 마치 공장 생산라인과 같이 명령어들을 명령어 파이프라인(Instruction Pipeline)에 넣고 동시에 처리하는 기법을 명령어 파이프라이닝(Instruction Pipelining)이라고 한다.

파이프라이닝은 높은 성능을 가져오기는 하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있다.

이런 상황을 파이프라인 위험(Pipeline Hazard)라고 한다.

1. 데이터 위험(Data Hazard)

명령어간 ‘데이터 의존성’에 의해 발생한다.

`모든 명령어를 동시에 처리할 수는 없다.`

```java
Inst1 : R1 = R2 + R3
Inst2 : R4 = R1 + R5
```

이 경우에는 명령어 1을 수행해야만 명령어 2를 수행할 수 있다.

명령어 1 실행이 끝나기 전에 명령어 2를 인출하면 R1에 R2 + R3의 결과값이 저장되기전에 R1값을 읽어들인다. 따라서 명령어 2는 명령어 1의 데이터에 의존적이다.

1. 제어 위험(Control Hazard)

주로 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생한다.

기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신된다.

하지만 프로그램 실행흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면, 명령어 파이프 라인에 미리 가지고와서 처리 중이었던 명령은 쓸모가 없어진다.

![Untitled 7](https://user-images.githubusercontent.com/70310271/210173730-380d2a03-9316-4abd-bd41-2af1afb08a9f.png)

이를 대비하기 위해 분기 예측(Branch Prediction)이라는 기술을 사용한다.

프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술이다.

1. 구조적 위험(Structural Harzard)

명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할때 발생한다.

구조적 위험은 자원 위험(Resource Hazard)라고도 부른다.

- 슈퍼 스칼라

파이프 라이닝은 단일 파이프라인으로도 구현이 가능하지만, 오늘날 대부분의 CPU에서는 여러개의 파이프라인을 사용한다.

CPU내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라(Super Scalar)라고 한다.

![Untitled 8](https://user-images.githubusercontent.com/70310271/210173732-6e12022c-e7ae-4c4a-8cab-d7e398a5b501.png)

슈퍼 스칼라는 공장 생산라인을 여러개 두는것과 같다.

슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서, 슈퍼스칼라 CPU라고 한다.

슈퍼 스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야한다.

ex) 멀티쓰레드 프로세서는 한번에 여러 명령어를 인출하고, 해석하고, 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있다.

이론적으로는 파이프라인 개수에 비례하여 프로그램 처리속도가 빨라진다 하지만, 파이프라인 위험등의 예상치 못한 문제 때문에, 반드시 비례하지는 않는다. 또한 위험을 방지하기 위해 고도로 설계되어야한다.

- 비순차적 명령어 처리(OoOE : Out of order Execution)

많은 전공서적에서 다루지 않지만, 오늘날 CPU 성능 향상에 크게 기여한 기법이고, 대부분의 CPU가 차용하고 있어 꼭 알아두자.

```java
M(0x01) = 1
M(0x02) = 2
M(0x03) = [M(0x01)] + [M(0x02)]
M(0x50) = 1
M(0x51) = 2
M(0x52) = 3
```

![Untitled 9](https://user-images.githubusercontent.com/70310271/210173737-b0ae75cf-91da-4843-b967-6e8368eb6eb9.png)

```java
M(0x01) = 1
M(0x02) = 2
M(0x50) = 1
M(0x51) = 2
M(0x52) = 3
M(0x03) = [M(0x01)] + [M(0x02)]
```

![Untitled 10](https://user-images.githubusercontent.com/70310271/210173753-dd1d4180-8446-4f98-8a17-d4cca817ad22.png)

이처럼 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는것을 방지하는 기법을 비순차적 명령어 처리 기법이라고 한다.

비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤것들이 있는지를 판단할 수 있어야한다.

## CISC와 RISC

### 명령어 집합

CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합(Instruction Set) 또는 명령어 집합 구조(Instruction Set Architecture)라고 한다.

feat) 명령어 집합에 아키텍쳐가 붙는 이유는 CPU가 어떤 명령어를 이해하는지에 따라 컴퓨터 구조 및 설계 방식이 달라지기 때문이다.

Intellij CPU는 x86-64 ISA를 이해하고 애플의 CPU는 ARM ISA를 이해하기 때문에 서로의 명령어를 이해할수 없다.

 

### CISC(Complex Instruction Set Computer)

x86, x86-64은 대표적인 CISC 기반의 ISA이다.

CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 `가변길이 명령어를 활용한다.`

x86-64코드 길이가 ARM보다 짧다. 

프로그램을 실행하는 명령어 수가 적다는건, 컴파일된 프로그램의 크기가 작다는걸 의미한다.

이런 장점 덕분에 CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았다.

메모리 공간을 절약할 수 있다는 장점이 있기 때문이다.

CISC에는 치명적인 단점이 있다.

활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않다.

또한 복잡한 명령어 때문에 명령어 하나를 실행하는데 여러 클럭 주기를 필요로 한다. 

![Untitled 11](https://user-images.githubusercontent.com/70310271/210173760-40687531-b425-4a20-b73f-34231b685c52.png)

이는 명령어 파이프라인을 구현하는데 큰 걸림돌이 된다.

명령어 파이프라인이 제대로 동작하지 않는다는것은 현대 CPU에서 아주 치명적인 약점이다.

현대 CPU에서 명령어 파이프라인은 높은 성능을 내기위해 절대 놓쳐서는 안되는 핵심 기술이다.

### RISC(Reduced Instruction Set Computer)

1. 빠른 처리를 위해 명령어 파이프라인을 활용해야한다.
2. 원활한 파이프라이닝을 위해 명령어 길이와 수행 시간이 짧고 규격화되어있어야한다.
3. 어차피 자주 쓰이는 명령어만 줄곧 사용되므로 복잡한 기능을 지원하는 명령어를 추가하기보다는 ‘자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는것이 중요하다.

CISC와 달리 짧고 규격화된 명령어이다. 되도록이면 1클럭 내외로 실행되는 명령어를 지향한다.

그래서 RISC는 `고정길이 명령어를 활용한다.`

RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다. 그렇기 때문에 CISC보다 주소 지정 방식의 종류가 적은 경우가 많다.

RISC는 메모리 접근을 단순화, 최소화 하는 대신 레지스터를 적극적으로 활용한다.

그렇기 때문에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용레지스터 개수도 더 많다.

그래서 RISC는 CISC보다 많은 명령으로 프로그램을 작동시킬 수 밖에 없다.

정리하자면

| CISC | RISC |
| --- | --- |
| 복잡하고 다양한 명령어를 가짐 | 단순하고 적은 명령어를 가짐 |
| 가변 길이 명령어 | 고정 길이 명령어 |
| 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클릭에 걸쳐 명령어 수행 | 1클럭 내외로 명령어 수행 |
| 파이프 라이닝하기 어려움 | 파이프 라이닝 하기 쉬움 |
