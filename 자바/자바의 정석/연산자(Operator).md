아는 내용은 과감히 적지 않았다.

### 연산자와 피연산자

연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.

### 식과 대입연산자

연산자와 피연산자를 조합하여 계산하고자 하는바를 표현한것을 식(Expression)이라 정의.

식을 계산하여 결과를 얻는 것을 ‘식을 평가(Evaluation)한다’라고 정의.

### 피연산자의 개수에 의한 분류

-3-5

-3의 -는 부호 연산자이고, 5앞의 -는 뺄셈연산자이다.

이처럼 서로 다른 연산자의 기호가 같은 경우도 있는데, 이럴 때는 피연산자의 개수로 구분이 가능하다.

### 연산자의 우선순위

주의 해야할 연산자

1. x << 2 + 1 →  +가 먼저 계산된다. (쉬프트 연산자)
2. data & 0xFF == 0 → ==가 먼저 계산된다. (비트연산자)
3. x< -1 || x> 3 && x < 5 → AND가 OR보다 먼저계산된다 (논리연산자)

애매할때는 괄호()를 쳐서 확실히 하는게 좋다.

참고. 괄호는 연산자가 아니다. 연산자의 우선순위를 임의로 지정할 때 사용하는 기호일뿐이다.

### 연산자의 결합규칙

같은 우선순위라면 왼쪽부터 하는게 일반적이다.

대입연산자는 오른쪽에서 왼쪽이다.

x = y = 3 → y = 3이 먼저 수행되고, y가 x에 다시 대입되는구조이다.

논리적으로는 그렇지만, x=3, y=3으로 이해해도 상관은 없다.

모든 연산자는 연산결과를 갖는다고 했는데, 대입연산자도 예외는 아니다.

대입 연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다.

### 산술변환 (Usual Arithmetic Conversion)

연산전에 피연산자 타입의 일치를 위해 자동 형변환 되는것을 ‘산술 변환’ 또는 ‘일반 산술 변환’이라 정의

일반적으로 연산시에 더 큰 피연산자의 자료형으로 변환된다.

하지만 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

ex)

byte + short → int + int → int

char+ short → int + int → int

정수형의 기본타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.

더 구체적으로 보자면

char 또는 short의 표현범위가 좁아서 연산중에 overflow가 발생할 가능성이 높아서이다.

## 단항 연산자

### 증감 연산자 ++ - -

++;와 i++;처럼 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우네는 전위형(prefix)와 후위형(postfix)의 차이가 없다.

전위형 증감연산자 연산과정

i의 값 증가 → i의 값을 참조 → 연산결과를 j에 저장

```python
j = ++i; -> ++i;
						j = i;
```

후위형 증감연산자 연산과정

i의 값을 참조 → 연산결과를 j에 저장 → i의 값 증가

```python
j = i++; -> j = i;
						i++;
```

### 부호 연산자 + -

boolean형과 char를 제외한 기본형에만 사용가능하다.

## 산술 연산자

### 사칙연산자

부동소수점 값인 0.0f, 0.0d로 나누는것은 가능하지만 그 결과는 무한대(Infinity)이다.

```python
class OperatorEx6 {
		public static void main(String[] args) {
				byte a = 10;
				byte b = 20;
				byte c = a + b; #(byte)(a+b);로 돌아감.
				System.out.println(c);
		}
}
```

모두 int형보다 작은 byte형이기 때문에 연산자 ‘+’는 이 두개의 피연산자들의 자료형을 int형으로 변환한 다음 연산을 수행한다.

```java
class OperatorEx8 {
    public static void main(String[] args) {
	      int a = 1_000_000; #1,000,000 
	      int b = 2_000_000; #2,000,000
				long c = a*b;  #(long)(a*b);
				System.out.println(c);
    }
}
```

이렇게 '_'를 사용하여 단위를 표시해도된다.

이또한 2000000000000가 출력되야하지만, -1454759936이 출력된다.

이유는 int * int는 int이기 때문이다.

한쪽에 L과 같은 접미사를 붙여서 연산시키는것도 방법이된다.

### ‘a’+1의 연산

상수 또는 리터럴 간의 연산은 실행과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다.

```java
// 컴파일 전
char c2 = ‘a’+1;
int sec = 60 * 60 * 24;

// 컴파일 후
char c2 = ‘b’;
int sec = 86400;
```

86400=60*60*24인데, 이렇게 풀어써도 결국 컴파일러에 의해서 미리 계산되기 때문에 실행 시의 성능차이는 없다.

```java
char lowerCase ='a';
char upperCase = (char) (lowerCase - 32);
```

참고 char형과 int형 간의 뺄셈 연산 결과는 int형이므로, 연산 후 char형으로다시 형변환해야한다는것을 잊지말자.

```java
float pi = 3.14592f;
float shortPi = (int)(pi * 1000) / 1000f;
```

int형 간의 나눗셈 ‘int / int’를 수행하면 int다.

```java
double pi = 3.141592;
double shortPi = (int) (pi * 1000 + 0.5) / 1000.0;
```

이 예제는 소수점 넷째자리에서 반올림하는 방법을 보여준다.

이전 예제와 다른 점은 반올림을 위해 0.5를 더해 준다는 것이다.

또는 Math.round(3141.592)의 결과는 3142이다.

// 그냥 Math.round 소수점 첫째자리에서 반올림한후 그 결과를 정수로 돌려주는 Method이다.

쓰자.

### 나머지 연산자 %

```java
System.out.println(10 % 8); 10을 8로 나눈 나머지 2가 출력된다.
System.out.println(10 % -8); 위와 같은 결과를 얻는다.

```

나머지 연산자(%)는 나누는 수로 음수도 허용한다. 그러나 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지 결과와 같다.

그냥 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.

## 비교 연산자

연산결과는 오직 true,false 둘중에 하나

비교연산자도 연산을 수행하기전에 형 변환을 통해 두 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다.

10==10.0f에서 10은 int타입이고 10.0f는 float타입이므로, 10을 float으로 변환한다음 비교한다.

```java

10 == 10.f -> true

'0' == 0 -> false

'A' == 65 -> true

'A' > 'B' -> false

'A'+1 != 'B' -> false

10.0 == 10.0f -> true 오차없이 저장가능

0.1 == 0.1f -> false #0.1000000149011612 저장 오차때문에 false
```

올바른 결과를 얻으려면 double타입의 값을 float타입으로 형변환한 다음에 비교해야한다.

그래야만 올바른 결과를 얻을수 있다.

```java
(float)0.10000000000000001 = 0.10000000149011612

0.10000000149011612 = 0.10000000149011612
```

### 문자열의 비교

비교 연산자 ‘==’ 대신 equal()이라는 메서드를 사용해야한다.

```java
String str1 = "abc";
String str2 = new String("abc");

"abc"=="abc"; -> true
str1 == "abc" -> true
str2 == "abc" -> false -> 내용은 같지만 서로 다른 객체이기 때문이다.

그렇기 때문에 문자열을 비교할 때는 항상 equals()을 사용한다.

str1.equals("abc") -> true
str2.equals("abc") -> true
```

String은 클래스 이므로 위 처럼 new를 사용해서 객체를 생성해야한다.

그러나 특별히 String만 new를 사용하지 않고 위와 같이 간단히 쓸수 있게 허용한다.

## 논리 연산자

10 < x < 20과 같이 표현하는것은 허용되지 않는다.

&&(AND)를 ||(OR)보다 먼저 연산한다는것 꼭 알고있자!

```java
‘0’ ≤ ch && ch ≤ ‘9’

‘0’ ≤ ‘5’ && ‘5’ ≤ ‘9’

48 ≤ 53 && 53 ≤ 57

true && true

true
```

연산순서는 변수가 먼저 바뀌고, ch가 문자코드에 맞는 정수로 바뀐후 계산된다.

ch가 소문자 또는 대문자인지 확인하는 코드

(’a’ ≤ ch && ch ≤ ‘z’) || (’A’ ≤ ch && ch ≤ ‘Z’)

### 효율적인 연산(Short circuit evaluation)

OR연산의 경우 좌측 피연산자가 true면 우측 피연산자의 값은 평가하지 않는다.

AND 연산자의 경우도 마찬가지로 좌측 피연산자가 false면 우측 피연산자는 평가하지 않는다.

그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질수 있다.

ex)실제로 소문자가 대문자보다 입력될 확률이 높다고 판단된다면

(’a’ ≤ ch && ch ≤ ‘z’) || (’A’ ≤ ch && ch ≤ ‘Z’) 소문자를 왼쪽에 두는것이다.

### 논리 부정 연산자 !

어떤 값에 논리 부정 연산자!를 사용하면 toggle button을 논리적으로 구현할수 있다.

### 비트연산자 & | ^ ~ << >>

비트 AND → &

비트 OR → |

비트 XOR → ^

비트 전환 연산자(1의보수연산 == 부정) → ~

비트 쉬프트 연산자

순환이 아니라 밀리고 0이 채워진다. 물론 음수 일때는 앞에 모두 1이채워진다.

ex) 8 << 2 → 10진수 8을 2진수로 변환한 비트칸에서 왼쪽으로 2칸 움직이는것이다.

쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int타입으로 자동 변환되고 연산 결과역시 int타입이 된다.

그러나 쉬프트 연산자는 달른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않는다 

x << n 은 $x* 2^n$ 의 결과와 같다.

x >> n 은 $x *2^{-n}$ ($x/2^n$)의 결과와 같다.

$12300 = 123 * 10^2$과 같은 맥락

곱셈이나 나눗셈 연산자를 사용하면 같은 결과를 얻을 수 있는데, 굳이 쉬프트 연산자를 제공하는 이유는 무엇일까? 그 이유는 속도 때문이다.

비트 연산자가 곱셈,나눗셈 연산보다 더 빠르다.

하지만, 코드의 가독성 때문에, 곱셈과 나눗셈을 주로 사용하고, 빠른 실행속도가 요구될때만, 쉬프트 연산자를 사용하는것이 좋다.

## 그 외의 연산자

### 조건 연산자 ? :

조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항연산자처럼 산술변환이 발생한다.

```java
x = x + (mod < 0.5 ? 0 : 0.5) 0과 0.5의 타입이 다르다.
x = x + (mod < 0.5 ? 0.0 : 0.5) 0이 0.0으로 변환되었다.
```

0과 0.5의 타입이 다르므로, 자동 형변환이 일어나서 double타입으로 통일되고 연산결과 역시 double타입이 된다.

### 대입연산자 = , op=

### lvalue와 rvalue

대입연산자의 왼쪽 피연산자를 'lvalue(left value)'라 하고, 오른쪽 피연산자를 'rvalue(right value)'라고 한다.

lavlue는 반드시 변수처럼 값을 변경할 수 있는 것이 와야한다.

그래서 리터럴이나 상수같이 값을 저장할수 없는 것들은 lvalue가 될 수 없다.

### 복합 대입 연산자 (op)=

op란 그냥 연산자이다.

ex) +=, -= , *=
