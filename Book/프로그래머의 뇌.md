# 프로그래머의 뇌

프로그래밍을 하다보면 늘 혼란(Confusion)이 일어난다.

## 코드가 초래하는 세가지 종류의 혼란

### 혼란의 첫번째 유형 : 지식의 부족

```java
2 2 2 2 2 T n // APL(A Programming Language)
```

T가 뭔지몰라서 발생하는 오류.

언어나 알고리즘 또는 업무 영역에 대한 지식이 없는 경우 발생하는 혼란.

### 혼란의 두번째 유형 : 정보의 부족

```java
public class BinaryCaluclator{
    public static void main(Integer n){
        System.out.println(Integer.toBinaryString(n));
    }
}
```

이진수 표현으로 변환하는 부분은 인지할수 있지만, toBinaryString() 메서드가 내부적으로 어떻게 작동하는지 모른다면 이 코드도 혼란 스러울 수 있다.

코드를 이해하기 위해 필요한 정보를 가지고 있지 못한 경우 발생하는 혼란

### 혼란의 세번째 유형 : 처리 능력의 부족

```java
LET N2 = ABS(INT(N))
LET B$ = ""
FOR N1 = N2 TO 0 STEP 0
    LET N2 = INT(N1 / 2)
    LET B$ = STR$(N1 - N2 * 2) + B$
    LET N1 = N2
NEXT N1
PRINT B$
```

변수이름이나 연산자를 통해 코드가 무슨일을 하는지 유추할 수 있지만, 모든 과정을 처리하기는 어렵다.각각의 단계가 실행되는것을 한눈에 파악할 수 없기 떄문에 혼란스럽다.

처리 능력(Processing Power)이 부족하기 때문이다.

변수에 임시로 저장되는 값을 모두 기억하거나, 각각의 경우 어떤 동작들이 수행되는지 동시에 알기가 쉽지않다.

### 코딩에 영향을 주는 인지과정

지식이 없다는것은 두뇌의 장기 기억 공간(Long-term-memory,LTM)에 해당 내용이 없다는것을 뜻한다.

지식의 부족 = LTM의 문제

지식이 아닌 어떤 정보가 부족할때는 단기기억 공간(Short-term-memory,STM)에 대한 내용이 없기 때문이다.

정보의 부족 = STM의 문제

많은 정보를 처리할 떄는 작업기억공간(Working Memory)에 영향을 미치는데 우리는 사고할 때 이 영역을 사용한다.

처리능력의 부족 = 작업 기억 공간의 문제

### LTM과 프로그래밍

우리가 어떤 일을 할때든 LTM이 사용된다. 가령 신발 끈을 묶을 때 근육이 무엇을 해야 할지 자동으로 기억한다.

APL 예제 코드를 읽을때, LTM을 가장 많이 사용한다.

우리가 APL키워드의 T의 의미를 알고 있다면 코드를 읽을때 그것을 LTM으로부터 인출(retrieval)할 것이다.

이 예제로 언어의 문법에 대한 지식도 중요하단걸 알 수 있다.

### STM과 프로그래밍

누군가와 통화중에 전화번호를 알려줄때 이 번호는 LTM에 저장되지 않고 STM에 우선 저장된다. STM이 기억할 수 있는 항목의 최대치가 12개를 넘지 않는다는점에 대부분의 학자가 동의한다.

Integer n이라는 사실을 기억하며, 계속해서 코드를 읽어나가는것이다.

mian을 읽을 때 이것은 STM에 저장되지만, 이 함수명을 사용하는 대신 main이라고 하는, 과거의 경험으로 인해 이미 LTM에 저장되어 있는 이름을 사용한다. 이것은 두 가지 인지과정이 서로 독립적으로 일어나는것이 아니라는것을 보여준다.

### 작업 기억 공간과 프로그래밍

실제 사고 작용은 LTM이나 STM이 아닌 작업 기억 공간에서 일어난다

생각, 아이디어, 해결책 같은 것들이 여기에서 만들어진다.

LTM은 HDD, STM은 메인 메모리, 작업 기억공간은 두뇌의 프로세서라고 볼 수 있다.

우리 머리는 코드를 실행해보면서 무슨 일이 일어날지 이해하려 시도한다.

이 과정을 트레이싱(Tracing)[추적]이라고 부르는데, 

머릿속에서 코드를 컴파일하고 실행하는 과정을 의미한다.

변수의 값을 코드 내에 별도로 적어놓고 싶은 마음이 들수가 있는데,

이러한 현상은 작업기억 공간이 꽉차서 더 많은 저오를 처리할 수 없을 때 나타날 수 있다. (4장에서 정보 과부하상태, 예방법을 배운다.)

### 인지 과정들의 상호작용

1. LTM에서 관련된 지식을 인출하는가?
2. LTM에서 인출했다면, 어떤 정보를 가져왔는가?
3. STM에 정보를 저장하는가?
4. STM에 구체적으로 어떤 정보를 저장하는가?
5. 관련이 없어 보여 무시하고 넘어가는 정보는 없는가?
6. 코드의 특정 부분을 광범위하게 작업 기억 공간을 사용해서 분석하는가?
7. 코드의 어떤 부분이 작업 기억 공간에 과부하를 주는가?
8. 코드의 그 부분들이 작업 기억 공간을 어떻게 사용하는지 이해하는가?

O,오메가, f는 함수아닐까?,

O O O O X , O , 지식적인 부분 (삼각형),X

모호한 단어를 보면 작업 기억 공간이 활성화되어 문맥속에서 적합한 의미를 찾으려고 한다.

### 코드를 신속하게 읽기

프로그램은 사람이 읽을 수 있도록 작성해야만 한다.

### 전문가는 초보자보다 코드를 더 잘 기억한다.

핵심은 초보자들은 단어를 기억하기 쉽게 나열하는 방식을 사용하고

“True is Real Then False”

숙련된 개발자들은 단어를 쓰임새의 단위로 맞춰서 기억한다.

“True False Boolean” , “If Else Then”

질문하는것도 좋다. → 코드의 구조는 어떻게 되어 있는가?

깊이 중첩된 구조, 중첩이 없는 평탄구조?

눈에 띄는 라인은 없는가?

코드에서 들여쓰기는 어떻게 되어 있는가?

코드에 간격은 있는가?

코드에 큰 뭉치처럼 보이는건 없는가?

### 청크로 묶을 수 있는 코드를 작성하는 방법

1. 디자인 패턴을 배운다.

공과대학교 컴퓨터 과학교수인 Walter Tichy의 현직자 대상 실험

1. Martha Elizabeth Crosby 

코드에 주석문이 있으면 새로운 팀원이 코드를 쉽게 이해 할 수 있다.

1. 주석문은 개발자가 코드를 청킹하는 방식에도 영향을 미친다.

Quyin Fan의 2010년 메릴랜드 대학교 박사 학위 논문

“이 함수는 이진트리를 중위 순회하며 프린트한다.”

위와 같은 고수준 주석문은 코드를 청크 단위로 쪼개는 데 도움이 된다.

반면 i++; 다음에 i를 1만큼 증가 같은 저수준 주석문을 넣는 것은 오히려 청킹 작업에 부담이 된다

### 즉, 올바른 표식(Beacon)을 남겨라.

코드를 청크로 쉽게 쪼갤 수 있도록 하라.

ex) class Node:

def print_in_order

Root, Tree라는 변수명, 주석문에 단어 “Tree”사용

Left, Right라는 필드명

표식은 코드를 읽고 이해하는 과정에서 소스 코드에 대해 개발자가 갖는 가정이 맞거나 틀린 것을 확인해주는 역할을 수행하기 때문에 매우 중요하다.

Node 클래스를 본다 → “트리에 관한 것이다.” 추론 가능

Left, Right를 사용한다 → “이진트리에 관한 것이다.” 더 좁은 추론 가능

- 단순 표식

root, tree가 단순 표식에 해당한다.

+,>,&& 같은 연산자, if, else같은 구조문도 그 자체로 코드의 기능에 대해 코드를 읽는 개발자에게 알려주기 때문에 단순 표식이라고 볼 수 있다.

- 복합 표식

복합 표식은 단순 표식으로 이루어진 좀 더 큰 단위의 코드로, 단순 표식들이 모여 함께 실행하는 기능에 대해 알려준다.

Left, Right는 둘이 합쳐 하나의 복합 표식을 형성한다.

즉, 개별적으로는 별로 의미가 없으나 같이 보면 의미가 있다.

for와 같이 변수 선언, 초기화, 값의 변화, 경계조건을 모두 포함하기 때문에 복합 표식이다.

1. 코드 선정

잘 알지 못하는 코드베이스를 선택하되 자신이 잘 아는 언어로 된 코드를 선정한다.

1. 코드 파악

1단계에서 선택한 메서드나 함수를 파악하고 코드가 하는일을 요약한다.

## 코드를 더 깊이 있게 이해하기

## 변수 역할 프레임 워크

이스턴 핀란드 대학교의 Jorma Sajaniemi 교수는 11개의 역할로 대부분의 변수를 설명할 수 있다고 주장한다.

### 변수의 11가지 역할

1. Fixed Value(고정 값)
2. Stepper
3. Flag
4. Walker
5. Most Recent Holder
6. Most Wanted Holder
7. Gatherer
8. Container → ex) array, list, stack, tree 등
9. follower

이전 값 혹은 다음 값을 추적하기 위한용도 ex) 연결리스트 이전값에 대한 포인터

1. Organizer

추가 적인 처리를 위해 변수의 값을 변환함.

1. temporary

```java
if (변하지 않는 값인가?)
    1. 고정값

else if (임시 저장 장소 인가?)
    1. 컨테이너
    2. 조직자
    3. 임시

else if (검사를 해야 하는가?)
    1. 플래그

if (반복을 해야 하는가?)
    1. 워커
    2. 최근값 보유자
    if 계수인가?
        1. 스테퍼 ex) i=0
        2. 지연되는가? -> ex) 추적자
    if 축적되는가?
        1. 모집자
    if 골라야 하는가?
        1. 목적값 보유자
```

위와 같은 변수 역할 프레임워크를 사용하면 사용하지 않은 학생보다 성과가 더 뛰어난 것으로 알려져 있다.

Jorma Sajaniemi et al,. “An experiment on Using Roles of Variables in Teaching Introductory Programming”, (2007)

### 프로그램 이해의 여러 단계

1. 초점(Focal Point)을 찾는다.

Entry Point에 해당한다.

예를 들어서 설명하자면, API를 호출했을 때, 해당하는 API의 바디 부분을 의미한다고 생각하면 편하다.

ex) main()일수도 있고, API일 수도있고 다양하다.

1. 초점으로부터 지식을 확장한다.

API 바디에 있는 객체와 메서드의 내용들을 하나하나씩 보면서 이해한다.

1. 관련된 개체로 부터 개념을 이해한다.

1. 여러 개체에 걸쳐있는 개념을 이해한다.

### 수학보다 언어

Chnatal S. Prat et al, “Relating Natural Language Aptitude to Individual Differences in Learning Programming Langugaes” (2020).

계산능력, 수학적 능력을 적용해야 하는 지식과 기술은 프로그래밍 능력에 대한 예측력이 작았다.

실험 참여자들 사이에서 겨우 2%의 편차가 나타났다.

### 주석으로 모르는 부분 표시하기 (모니터링)

모르는 부분은 ?로 표시하고 아는 부분은 O로 표시한다.

처럼 기호로 표시해 둔다.

이 라인의 역할은 무엇인가?

이 라인은 프로그램의 전체 목적과 어떻게 관련되는가?

### 변수의 이름

이 변수에 대한 도메인 혹은 주제는 무엇인가?

이 변수에 대해 어떤 프로그래밍 개념들이 사용되었는가?

배경을 알지 않으면 의미가 모호한 이름이 있는가?

모호한 변수명이 해당 코드에서 가질 만한 의미는 무엇이 있을까?

서로 관련되어 있는 이름은 무엇인가?

이름으로부터 알 수 있는 사실은 무엇인가?
