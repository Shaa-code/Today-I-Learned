# 객체지향 프로그래밍2

## 상속(Inheritance)

### 상속이란?

기존의 클래스를 재사용하여 새로운 클래스를 작성하기위한 행위.

### 상속을 사용하는 이유

적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리하기 위해서.

즉, 코드의 추가 및 변경을 용이하게 하기 위해서 사용한다.

객체 지향의 특징인

코드의 재사용성, 코드의 중복제거, 생산성과 유지보수에 크게 기여하기때문에 중요하다.

Java에서 상속을 구현하는 방법

```java
class Child extends Parent {...} // Chiled -> Parent로 기억하면 쉬울듯 하다
```

```java
조상 클래스 = 부모(Parent)클래스 = 상위(Super)클래스 = 기반(Base)클래스
자손 클래스 = 자식(Child)클래스 = 하위(Sub)클래스 = 파생된(Derived)클래스
```

클래스가 복잡해지면, 상속관계도를 그려서 확인하면 보다 쉽게 이해할 수 있다.

상속은 햇갈리기 쉽다.

Parent가 상속한다. 그리고 Parent가 더 작은 집합을 가진다. (상속하기)

Child는 상속받는다. 그리고 Child는 더 큰 집합을 가진다. (상속받기)

**생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.**

**자손 클래스의 멤버 개수는 조상클래스보다 항상 같거나 많다.**

접근제어자(Access Modifier)가 private 또는 default인 멤버들은 상속되지 않는게 아니라,

상속은 받지만 자손클래스로부터 접근이 제한되는것이다.

이전에 배운 초기화 블록(Initialization Block)과 비슷하게 사용된다.

### 초기화 블록을 사용한 중복제거와 상속을 사용한 중복제거의 차이는 무엇일까?

한번 생각해보자.

초기화 블럭의 목적은 중복된 초기화를 없애기 위함,

상속은 중복된 선언을 하지 않기 위함인것같다.

초기화 블록에서는 변수선언이 안된다.

상속은 이미 선언된 변수를 끌어다 쓰는것이다.

당연하게도 자손클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 클래스간의 관계 - 포함관계

상속 이외에도 클래스를 재사용하는 또 다른 방법이 있다.

클래스 간에 ‘포함(Composite)”관계를 맺어 주는것이다.

```java
class Circle{
    int x;
    int y;
    int r;
}

->

class Circle {
    Point c = new Point();
    int r;
}
```

### 클래스간의 관계 결정하기

생각해보면 상속과 포함관계 둘중 무엇을 쓸지 고민된다.

정답은 없지만, `사람이 이해하기 쉬운 직관적인 이해를 기준으로 한다.`

```java
class Circle {
    Point c = new Point();
    int r;
}

==

class Circle extends Point {
    int r;
}
```

is -a 관계이면, 상속을 쓰는게 이해하기 편하고

has -a 관계이면, 포함관계로 쓰는게 이해하기 편하다.

ex)

Circle is a Point

Circle has a Point

`프로그램의 모든 클래스를 분석하여 가능한 많은 관계를 맺도록 노력해서 코드의 재사용성을 높여야한다.`

 

```java
import java.util.*;

class VarEx1 {
    public static void main(String[] args){
    Point[] p1 = {  new Point(100,100),
                    new Point(140,50),
                    new Point(200,100) };

    Triangle t = new Triangle(p1);
    Circle c = new Circle(new Point(150,150), 50);

    t.draw();
    c.draw();

    }
}

class Shape{
    String color = "black";
    void draw(){
        System.out.println(color);
    }
}

class Point{
    int x,y;

    Point(){
        this(0,0);
    }

    Point(int x, int y){
        this.x = x;
        this.y = y;
    }

    String GetXY(){
        return "("+x+","+y+")";
    }

}

class Circle extends Shape{

    Point p1;
    int r=0;

    Circle(){
        this(new Point(0,0),100);
    }

    Circle(Point center,int radius){
        this.p1 = center;
        this.r = radius;
    }
}

class Triangle extends Shape{
    Point[] p = new Point[3];

    Triangle(Point[] p){
        this.p = p;
    }

    void draw(){
        System.out.printf("[p1=%s, p2=%s, p3=%s, color = %s%n",p[0].GetXY(),p[1].GetXY(),p[2].GetXY(),color);
    }
}
```

Circle c = new Circle(new Point(150, 150), 50); 인자 자체를 new Point로 바로 선언한다.

Point[] p1 = { new Point(100, 200), new Point( 300,400), new Point(500,600) ; }

배열은 이렇게 받도록 한다.

```java
class VarEx1 {
    public static void main(String[] args){
        Deck d = new Deck();
        Card c = d.pick(0);
        System.out.println(c);

        d.shuffle();
        c = d.pick(0);
        System.out.println(c);
    }
}

class Deck{
    final int CARD_NUM = 52;
    Card cardArr[] = new Card[CARD_NUM];

    Deck(){
        int i=0;
        for (int k=Card.KIND_MAX; k > 0; k--)
            for (int n=0; n < Card.NUM_MAX ; n++)
                cardArr[i++] = new Card(k,n+1);
    }

    Card pick(int index){
        return cardArr[index];
    }

    Card pick(){
        int index = (int)(Math.random() * CARD_NUM);
        return pick(index);
    }

    void shuffle(){
        for(int i = 0; i < cardArr.length; i++){
            int r = (int)(Math.random() * CARD_NUM);

            Card temp = cardArr[i];
            cardArr[i] = cardArr[r];
            cardArr[r] = temp;

        }
    }
}

class Card {
    static final int KIND_MAX = 4;
    static final int NUM_MAX = 13;
    static final int SPADE = 4;
    static final int DIAMOND = 3;
    static final int HEART = 2;
    static final int CLOVER = 1;
    int kind;
    int number;

    Card() {
        this(SPADE, 1);
    }

    Card(int kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    public String toString() {
        String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
        String numbers = "0123456789XJQK";
        return kinds[this.kind] + " " + " " + numbers.charAt(this.number);
    }
}

```

하나하나 직접 메서드를 만들어보면, 논리구조를 조금 더 확실히 이해할 수 있다.

Card객체에 실제로 저장된 것은 객체가 아니라 객체의 주소이다.                    

```java
System.out.println(c);
System.out.println(c.toString());
```

두가지는 같은 결과 값을 얻는다. 

toString자체가 Object클래스에 정의된 것으로 참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리한다.

## 단일 상속

C++에서는 여러 조상 클래스로부터 상속받는것이 가능한 ‘다중상속’을 허용하지만 자바에서는 오직 단일 상속만을 허용한다.

왜 단일 상속만을 사용할까?

1. 클래스간의 관계가 매우 복잡해지기 때문.
2. 서로 다른 클래스로 부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없기 때문.

즉, 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들기 위해서 사용한다.

```java
class Tv{
    boolean power;
    int channel;
    void power() {power = !power;}
    void channelUp() { ++channel;}
    void channelDown() {--channel;}
}

class VCR{
    boolean power;
    int counter = 0;
    void power() {power = !power;}
    void play() {}
    void stop() {}
    void rew() {}
    void ff() {}
}

class TVCR extends Tv{
    VCR vcr = new VCR();
    void play(){
        vcr.play();
    }
    void stop() {
        vcr.stop();
    }
    void rew() {
        vcr.rew();
    }
    void ff() {
        vcr.ff();
    }
}
```

다중상속과 비슷하게 구현하려면, 하나의 조상을 받고 포함관계로 나타내면 된다.

보는것처럼 TVCR에서 Tv만 단일 상속후 VCR은 포함관계로 객체를 생성해서 받는다.

그렇게 하면, VCR클래스의 메서드의 내용이 변경되어도 TVCR클래스의 메서드들 또한 변경된 내용이 적용되는 결과를 얻을 수 있다.

### Object Class - 모든 클래스의 조상

Object클래스는 모든 클래스 상속 계층도의 최상위에 있는 조상클래스이다.

다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

```java
class Tv {} -> class Tv extends Object {}
```

컴파일시에 컴파일러는 위의 코드를 자동적으로 ‘extends Object’를 추가하여 Tv클래스가 Object클래스로 부터 상속받도록 한다.

하지만 이미 어떤 클래스로부터 상속받도록 작성된 클래스에 대해서는 컴파일러가 ‘extends Object’를 추가하지 않는다.

```java
class Tv {} -> class CaptionTv extends Tv{}
```

CaptionTv → Tv → Object

## 오버라이딩(Overriding)

### 오버라이딩이란?

조상클래스로 부터 상속받은 메서드의 내용을 변경하는것을 ‘오버라이딩’이라고 한다.

### 오버라이딩의 조건

자손 클래스에서 오버라이딩하는 메서드는 조상클래스의 메서드와 이름이 같아야한다.

- 이름이 같아야한다.
- 매개변수가 같아야한다.
- 반환타입이 같아야한다.

JDK1.5부터 ‘공변 반환타입(covariant return type)’이 추가되어, 반환타입을 자손 클래스의 타입으로 변경하는것은 가능하도록 조건이 완화되었다.

다만 접근 제어자(Access Modifier) 예외(Exception)은 제한된 조건하에서만 다르게 변경할 수 있다.

1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
    
    public → protected → (default) → private
    
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
    
    ```java
    class Parent{
        void parentMethod() throws IOException, SQLException{
        }
    }
    
    class Child extends Parent{
        void parentMethod() throws Exception{
        }
    }
    ```
    

단순히 선언된 갯수가 아니다. Exception은 모든 예외의 최고 조상이고 가장 많은 개수의 예외를 던질 수 있도록 선언한것이다.

그래서 보이는것은 Exception 1개이지만, 논리상으로는 모든 예외들로 인식되기 때문에 잘못된 오버라이딩이다.

1. 인스턴스 메서드를 static 또는 그 반대로 변경할 수 없다.
    
    조상클래스에 정의된 static메서드를 자손클래스에서 똑같은 이름의 static메서드로 정의할 수 있는가?
    
    가능하다.
    
    `하지만 이것은 각 클래스에 별개의 static메서드를 정의한 것일 뿐 오버라이딩이 아니다.`
    
    static멤버들은 자신들이 정의된 클래스에 독립되어 묶여있다고 생각하자.
    

### 오버로딩 vs 오버라이딩

오버로딩(Overloading) : 기존에 없는 새로운 메서드를 정의하는것 → New

오버라이딩(Overriding) : 상속받은 메서드의 내용을 변경하는것  → Modify

### super (복습필요)

부모클래스의 변수 명과 자식클래스의 변수 명이 같을때, 구분시켜주는 참조변수이다. 

부모클래스의 변수를 가지고 온다.

```java
class VarEx1 {
    public static void main(String[] args){
        Child c = new Child();
        c.method();
    }
}

class Parent{
    int x = 10;
}

class Child extends Parent{
    int x = 20;
    void method(){
        System.out.println(x);
        System.out.println(this.x);
        System.out.println(super.x);
    }
}
```

super는 메서드에도 적용이 가능하다.

```java
class Point{
    int x;
    int y;

    String getLocation(){
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;
    String getLocation() {
        //return "x :" + x + ", y: " + y + " , z :" + z;
        return super.getLocation() + ", z:" + z;
    }
}
```

조상클래스에 선언된 메서드에 내용을 추가한다면 super를 사용하는것이 좋다.

→ 당연하게도 여러번 수정하지 않아도 되기 때문이다.

`this와 super는 static 메서드에서는 사용할 수 없고 인스턴스 메서드에서만 사용할 수 있다.`

### 생성자의 첫줄에서 생성자를 호출해야하는 이유

super또한 this와 같이 생성자의 첫줄에서 위치되어야한다.

`자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야한다.`

이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 거술러 올라가면서 계속 반복된다.

마지막으로 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝난다.

그래서 Object 클래스를 제외한 모든 클래스의 생성자는 첫줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야한다.

그렇지 않으면 컴파일러는 생성자의 첫줄에 super();를 자동적으로 추가한다.

```java
import java.util.*;

class VarEx1 {
    public static void main(String[] args){
        Point3D p3 = new Point3D(1,2,3);
    }
}

class Point {
    int x, y;

    Point(int x, int y){
        //super(); -> Object()
        this.x = x;
        this.y = y;
    }

    String getLocation(){
        return "x :" + x + ", y:"+ y;
    }
}

class Point3D extends Point{
    int z;

    Point3D(int x, int y, int z){
        //기본 : super(); -> 매개변수 : super(x,y);
        this.x = x;
        this.y = y;
        this.z = z;
    }

    String getLocation(){
        return super.getLocation() + "z : " + z;
    }
}
```

이 상태에서는 오류가 난다. 이유를 잘 찾아보자. 

super()는 Point3D클래스의 조상인 Point클래스의 기본 생성자인 Point()를 뜻한다.

하지만 Point클래스에는 기본 생성자가 정의되어 있지 않으므로 super(x,y)를 추가해주면 된다.

## package 와 import

### 패키지(Package)

패키지란? → 클래스의 묶음이다.

패키지에는 클래스 또는 인터페이스를 포함시킬수 있다.

단순히 클래스이름으로 구분했지만, 사실 클래스의 실제 이름(full name)은 패키지명을 포함한 것이다.

String의 실제이름은 java.lang.String이다.

패키지가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.

클래스 파일들을 압축한것이 jar파일(*.jar)이다.

### 패키지의 선언

package 패키지명;

주석과 공백을 제외한 첫 번째 문장이어야 하며, 하나의 소스파일에 단 한번만 선언될 수 있다.

패키지명은 대소문자 모두 허용하지만, 클래스명과 쉽게 구분하기 위해서 소문자로 하는것을 원칙으로 하고있다.

모든 클래스는 반드시 하나의 패키지에 포함되어야한다.

그럼에도 불구하고 지금까지 소스파일을 작성할 때 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는 자바에서 기본적으로 제공하는 ‘이름없는 패키지(unnamed package)’때문이다.

소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 ‘이름 없는 패키지’에 속하게 된다.

```java
C:\Users\Shaa\IdeaProjects\Helloworld\src> javac -d . VarEx1.java
```

‘-d’옵션은 소스파일에 지정된 경로를 통해 패키지의 위치를 찾아서 클래스파일을 생성한다.

-d 뒤에는 해당 패키지의 루트 디렉토리의 경로를 적어준다.

CLASSPATH를 설정해줘야만, 실행시 JVM이 위의 클래스를 찾을 수 있다.

classpath는 컴파일러나 JVM등이 클래스의 위치를 찾는데 사용되는 경로이다.

```java
.;C:\Users\Shaa\IdeaProjects\Helloworld\src\
```

맨앞에 ‘.;’를 추가한 이유는 현재의 디렉토리(.)를 클래스패스에 포함시키기 위해서다.

jar파일을 클래스 패스에 추가하기 위해서는 경로와 파일명을 적어주어야한다.

```java
C:\WINDOWS> SET CLASSPATH = .;C:\Users\Shaa\IdeaProjects\Helloworld\src\com\codechobo\book\util.jar;
```

### 적용된지 확인하는법

C:\Windows 에서 echo %classpath%를 해보면 경로가 나온다.

---
### 오류발생

**Error: A JNI error has occurred, please check your installation and try again**

a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 52.0

버전이 서로 맞지 않아서 발생하는 문제이다.

**1. javac 명령어에 "--release 8"을 추가하여 낮은 버전으로 자바 버전을 맞춘다.**

(빠름, 일시적)

**2. 환경변수를 수정하여 java와 javac 명령어가 사용하는 자바의 버전을 맞춘다.**

(귀찮음, 비교적 영구적)

<참고>[https://hoohaha.tistory.com/41](https://hoohaha.tistory.com/41)

---

JDK에 기본적으로 설정되어있는 클래스패스를 이용하면 위의 예제에서와 같이 클래스패스를 따로 설정하지 않아도 된다.

새로 추가하고자 하는 클래스를 ‘JDK설치디렉토리\jre\classes에 넣으면 따로 이름을 넣지 않아도된다.

jre디렉토리 아래의 classes디렉토리는 JDK설치 시에 자동으로 생성되지 않으므로 사용자가 직접 생성해야한다.

jar파일인 경우  ‘JDK설치디렉토리\jre\lib\ext’에 넣으면 된다.

또는 실행 시에 ‘-cp’옵션을 이용해서 일시적으로 클래스패스를 지정해 줄수도 있다.

```java
C:\WINDOWS>java -cp C:\Users\Shaa\IdeaProjects\Helloworld\src com.codechobo.book.VarEx1
```

### Import문

import문은 프로그램의 성능에 전혀 영향을 미치지 않는다.

import문을 많이 사용하면 컴파일 시간이 아주 조금 더 걸릴 뿐이다.

```java
import 패키지명.클래스명;
import 패키지명.*;
```

클래스이름을 *을 사용하면, 컴파일러는 해당 패키지에서 일치하는 클래스이름을 찾아야하는 수고를 더해야 한다.

`실행 시 성능상의 차이는 전혀없다.`

```java
import java.util.Calendar;
import java.util.Date;
import java.util.ArrayList;

->

import java.util.*;
```

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class VarEx1 {
    public static void main(String[] args){
        Date today = new Date();

        SimpleDateFormat date = new SimpleDateFormat("yyyy/MM/dd");
        SimpleDateFormat time = new SimpleDateFormat("hh:mm:ss a");

        System.out.println(date.format(today));
        System.out.println(time.format(today));
    }
}
```

```java
java.util.Date Today = new java.util.Date()

java.text.SimpleDateFormat date = new java.text.SimpleDateFormat(”yyyy/MM/dd”);

java.text.SimpleDateFormat time = new java.text.SimpleDateFormat(”hh:mm:ss a”);
```

import문으로 패키지를 지정하지 않으면 모든 클래스앞에 패키지명을 붙여야한다.

지금까지 System과 String같은 java.lnag패키지의 클래스들을 패키지명 없이 사용할 수 있었던 이유는 모든 소스파일에는 묵시적으로 import java.lang.*;이 선언되어있기 때문이다.

java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 된다.

### static import문

static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

사용이유 : `특정 클래스의 static멤버를 자주 사용할 때 쓰기 위해서.`

```java
import static java.lang.Integer.*; // Integer클래스의 모든 static메서드
import static java.lang.Math.random; //괄호를 붙이지 않고 선언
import static java.lang.System.out; // System.out을 out만으로 참조가능
```

```java
import static java.lang.System.out;
import static java.lang.Math.*;

class VarEx1 {
    public static void main(String[] args){
        out.println(random());
        out.println(PI);
    }
}
```

## 제어자(modifier)

### 제어자란?

제어자(modifier)는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

접근제어자 : public, protected, default, private

그외 : static final, abstract, native, transient, sysnchronized, vlatile, strictfp

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는것이 가능하다.

제어자들 간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.

### static

- 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
    - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    - 클래스가 메모리에 로드될 때 생성된다.
- 메서드
    - 인스턴스를 생성하지 않고도 호출이 가능한 static메서드가 된다.
    - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.
- static초기화 블럭
    
    클래스가 메모리에 로드될때 단 한번만 수행되며, 주로 클래스변수(static변수)를 초기화하는데 주로 사용된다.
    

### final

- 클래스
    - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
    - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
- 메서드
    - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
- 멤버변수,지역변수
    
    변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 된다.
    
    간략화 : 상속 금지, 오버라이딩 금지, 변경금지(상수로 선언)
    

### 생성자를 이용한 final멤버 변수의 초기화

final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만,

인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.

이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버 변수가 다른값을 갖도록 하는것이 가능하다.

```java
class VarEx1 {
    public static void main(String[] args) {
        Card c1 = new Card("HEART",10); -> 이렇게 생성자로 바로 초기화 할수도 있다.
    }
}

class Card{
    final String KIND; // 여기서 바로 초기화해도 된다.
    final int NUMBER; // 여기서 바로 초기화해도 된다.

    Card(String kind, int num){
        this.KIND = kind;
        this.NUMBER = num;
    }

    Card(){
        this("HEART",1);
    }

    public String toString(){
        return KIND+ " " + NUMBER;
    }
}
```

객체를 생성할때, 생성자를 이용하여서 final을 초기화 할수도 있다는 의미이다.

Tip) 카드의 값을 변경할때에 오류가 발생한다면 큰 오류가 될수 있다. 반면에, 오류가 나더라도 순서를 바꾸는 방법으로 로직을 만들었다면 오류가 발생하더라도 조금 더 안전한 오류일 수 있다.

### abstract

- 클래스

클래스 내에 추상 메서드가 선언되어 있음을 의미한다.

- 메서드

선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다.

추상클래스는 아직 완성되지 않은 메서드가 존재하는 ‘미완성 설계도’이므로 인스턴스를 생성할 수 없다.

이 클래스자체로는 쓸모가 없지만, 다른 클래스가 이 클래스를 상속받아서 일부의 원하는 메서드만 오버라이딩해도 된다는 장점이 있다. 

만일 이 클래스가 없다면 아무런 내용도 없는 메서드를 잔뜩 오버라이딩해야한다.

### 접근제어자 (Access Modifier)

private : 같은 클래스 내에서만 접근이 가능하다.

default : 같은 패키지 내에서만 접근이 가능하다.

protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.

public : 접근 제한이 전혀없다.

![Untitled](https://user-images.githubusercontent.com/70310271/168010340-dc43cb3c-f27c-42a9-b23c-4c7fe653f85d.png)

### 접근 제어자를 이용한 캡슐화

데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는것이 필요하다.

이것을 데이터 감추기(data hiding)이라고 하며, 객체지향개념의 캡슐화(encapsulation)에 해당한다.

또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 부분을 감추기 위해서이다.

사용하는 이유

- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

만일 메서드 하나를 변경해야 한다고 가정했을때, 이 메서드의 접근 제어자가 public이라면, 메서드를 변경한 후에 오류가 없는지 테스트해야하는 범위가 넓다.

그러나 접근 제어자가 default라면 패키지내부만 확인해보면되고, private이면 클래스하나만 살펴보면된다.

→ 이러한 이유로도 사용된다.

```java
class VarEx1 {
    public static void main(String[] args) {
        Time t = new Time(12,35,30);
out.println(t);
        t.hour = 13; // 오류남
        t.setHour(t.getHour()+1);
        System.out.println(t);
    }
}

class Time{
    private int hour,minute,second;

    Time(int hour, int minute, int second){
        setHour(hour);
        setHour(minute);
        setHour(second);
    }

    public int getHour() {
        return hour;
    }

    public void setHour(int hour) {
        if (hour < 0 || hour > 23) return;
        this.hour = hour;
    }

    public int getMinute() {
        return minute;
    }

    public void setMinute(int minute){
        if (minute < 0 || minute > 59) return;
        this.minute = minute;
    }

    public int GetSecond() {
        return second;
    }

    public void SetSecond(int second){
        if (second < 0 || second > 59) return;
        this.second = second;
    }

    public String toString(){
        return hour + ":" + minute + ":" + second;
    }

}
```

보다시피 변수에 범위를 두고싶다면, 조건을 검사하는 메서드를 따로 구현해야한다.

### 생성자의 접근 제어자 (연습해야하는 개념)

생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게된다. 그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```java
class VarEx1 {
    public static void main(String[] args){
        Singleton s = new Singleton();
        Singleton s = Singleton.getInstance();
    }
}

final class Singleton{
    private static Singleton s = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        if(s==null)
            s = new Singleton();
        return s;
    }
}
```

직접 생성자에 접근할 수 없으므로 getInstance메서드를 만들어서 객체를 초기화하는 방식을 사용한다.

### Q1. 왜 private Singleton이 아닌 private static Singleton인가?

static으로 선언해야만, 클래스가 메모리에 올라감과 동시에 인스턴스 변수 s를 생성할것이고,

이후에 getinstance()에서 사용될 수 있기 때문이다.

→ `굉장히 중요하다.`

fianl을 추가하여 상속할 수 없는 클래스라는 것을 알리는것이 좋다.

### 제어자(Modifier)의 조합

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
    
    static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
    
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
    
    클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기때문이다.
    
3. abstract메서드의 접근제어자가 private일 수 없다.
    
    abstract메서드는 자손클래스에서 구현해주어야하는데 접근제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.
    
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
    
    접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다.
    

## 다형성(Polymorphism)

객체지향 개념에서 다형성이란 ‘여러가지 형태를 가질 수 있는 능력’을 의미하며,

조상클래스의 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는것이다.

```java
class Tv{
    boolean power;
    int channel;
    
    void power(){}
    void channelUp(){}
    void channelDown(){}
}

class CaptionTv extends Tv{
    String text;
    void caption(){}
}

->

CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```

참조변수 t는 실제 인스턴스가 CaptionTv타입이라 할지라도, 참조변수 t로는 CaptionTv인스턴스의 멤버를 사용할 수 없다.

Tv타입의 참조변수로는 CaptionTv의 인스턴스중에서 Tv클래스의 멤버들만 사용할 수 있다.

즉, text와 caption()는 참조변수 t로 사용할 수 없다는 소리이다.

둘다 같은 타입의 인스턴스이지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

```java
CaptionTv c = new Tv();
```

이 코드는 작동이 가능할까?

그렇지 않다. 컴파일에러가 발생한다.

그 이유는 실제 인스턴스인 Tv의 멤버개수보다 참조변수 c가 사용할 수 있는 멤버개수가 더 많기 때문이다.

`멤버의 개수가 더 많으면 허용될 수 있는것 아닌가?` 생각할 수 있지만,

c가 참조하고 있는 인스턴스는 Tv타입이고, Tv타입의 인스턴스에는 text, caption()이 존재하지 않기 때문에 이들을 사용하려 하면 문제가 발생한다.

즉, 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는것은 `존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용되지 않는것이다.`

참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야한다.

Q1.

인스턴스의 타입과 일치하는 참조변수를 사용해서 인스턴스의 멤버들을 모두 사용하도록 하면되지

왜 굳이 조상타입의 참조변수를 사용해서 인스턴스의 일부멤버만을 사용하려고 하는걸까?

### 참조변수의 형변환

```java
class Test {
    public static void main(String[] args){
        Car car = null;
        FireEngine fe = new FireEngine();
        FireEngine fe2 = null;

        fe.water();
        car = fe; // car = (Car)fe; (Car)생략된것.
        car.water(); //car타입의 참조변수로는 water()를 호출할 수 없다.
        fe2 = (FireEngine)car;
        fe2.water();
    }
}

class Car{
    String color;
    int door;
    void drive(){}
    void stop(){}
}

class FireEngine extends Car{
    void water(){}
}

class Ambulance extends Car{
    void siren(){}
}
```

서로 상속관계에 있는 클래스사이에서 기본형 변수와 같이 참조변수도 형변환이 가능하다.

바로 윗조상이나 자손이 아닌, 조상의 조상으로도 형변환이 가능하다. 따라서 모든 클래스의 조상인 object클래스 타입으로 형변환이 가능하다.

`참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는것 뿐이다.`

이때 car = fe가 실행될때는 참조변수fe가 참조하고 있는 인스턴스를 참조변수 car가 참조하도록 한다.

fe와 car가 둘다 FireEngine인스턴스를 사용할 수 있게 되었지만, fe와는 달리 car는 Car타입이므로 Car클래스의 멤버가 아니다. 그러므로 water()를 사용할수 없다.

```java
Car car = new Car();
Car car2 = null;
FireEngine fe = null;

car.drive();
fe = (FireEngine)car; // 오류발생 CastingTest2.main(CastingTest2.java:8)
fe.drive();
car2 = fe;
car2.drive();
```

컴파일은 되지만, 실행시 오류가 발생하는 코드이다.

참조변수 car가 참조하고 있는 인스턴스가 Car타입의 인스턴스라는게 문제다.

조상타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다.

![Untitled 1](https://user-images.githubusercontent.com/70310271/168278714-175e9c27-5e43-4984-a138-b0b1472a3034.png)

FireEngine을 Ambulance로 생각하고 한번 생각해보자!

### instanceof 연산자

instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.

연산결과는 true,false 중 하나.

`instanceof를 이용한 연산결과로 true를 얻었다는것은 참조변수가 검사한 타입으로 형 변환이 가능하다는것을 뜻한다.`

값이 null인 참조변수에 대해 instanceof연산을 수행하면 false의 결과를 얻는다.

왜 사용하는거지?

```java
void doWork(Car c){
    if(c instanceof FireEngine){
        FireEngine fe=(FireEngine)c;
        fe.water()
    } else if (c instanceof Ambulnace){
        Amublance a = (Ambulance)c;
        a.siren()
}
```

매개변수로 Car클래스 또는 그 자손 클래스의 인스턴스를 넘겨받겠지만 메서드 내에서는 정확히 어떤 인스턴스인지 알길이 없다. 그렇기 때문에, instanceof연산자를 이용해서 참조변수 c가 가리키고 있는 인스턴스의 타입을 체크하고, 적절히 형변환한 다음에 작업을 해야한다.

확실하게 얻어갈것. 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는것을 뜻 한다.

### 참조변수와 인스턴스의 연결

조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻는다.

조상타입의 참조변수를 사용했을때는 조상 클래스에 선언된 멤버변수가 사용된다.

자손타입의 참조변수를 사용했을때는 자손 클래스에 선언된 멤버변수가 사용된다.

```java
class CodeTest{
    public static void main (String[] args){
        Parent p = new Child();
        Child c = new Child();

        System.out.println(p.x);
        p.method();

        System.out.println(c.x);
        c.method();
    }
}

class Parent{
    int x = 100;
    void method(){
        System.out.println("Parent Method");
    }
}

class Child extends Parent{
    int x = 200;
    void method(){
        System.out.println("Child Method");
    }
}

/*
실행결과

100
Child Method
200
Child Method

*/
```

p는 Parent의 멤버들을 사용.

c는 Child의 멤버들을 사용.

`보다시피 메서드의 경우 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드가 호출된다.`

그러나, 멤버변수의 경우에는 참조변수의 타입에 따라 달라진다.

멤버(p)는 참조변수의 타입(Parent)을 따라가고, 메서드는 오버라이딩된 Child를 따라간다.

```java
class CodeTest{
    public static void main (String[] args){
        Parent p = new Child();
        Child c = new Child();

        System.out.println(p.x);
        p.method();

        System.out.println(c.x);
        c.method();
    }
}

class Parent{
    int x = 100;
    void method(){
        System.out.println("Parent Method");
    }
}

class Child extends Parent{}
```

중복으로 정의되어 있지 않으면, 단순히 조상으로부터 멤버들을 상속받는다.

### 매개변수의 다형성 (`굉장히 중요하다.`)

하나하나 계속 매개변수를 추가해 줄 필요없이 하나의 매개변수를 가지고 들어오는 모든 인자들을 처리할 수 있도록 만들어주는 방법.

```java
class CodeTest{
    public static void main(String[] args){
        Buyer b = new Buyer();
        b.buy(new Tv());
        b.buy(new Computer());

        System.out.println(b.money + "남은돈");
        System.out.println(b.bonusPoint +"남은보너스");
    }
}

class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price = price;
        this.bonusPoint = (int)(price/10.0);
    }
}

class Tv extends Product{
    Tv(){
        super(100);
    }
    public String toString() {return "Tv";}
}

class Computer extends Product{
    Computer(){
        super(200);
    }
    public String toString() {return "Computer";}
}

class Buyer {
    int money = 1000;
    int bonusPoint = 0;

    void buy(Product p) {
        if (money < p.price) {
            System.out.println("잔액부족");
        }

        this.money -= p.price;
        this.bonusPoint += p.bonusPoint;
        System.out.println(p + "을/를 구입");
    }
}
```

buy(Tv t), buy(Computer c), buy (Audio) 이렇게 매개변수를 하나하나 추가할 필요없다.

buy(Product p) 하나로 모두다 처리할수 있다는 큰 장점이있다.

### 여러 종류의 객체를 배열로 다루기(`굉장히 중요하다.`)

Product클래스가 Tv,Computer,Audio클래스의 조상일 때

```java
class CodeTest{
    public static void main(String[] args){
        Buyer b = new Buyer();
        b.buy(new Tv());
        b.buy(new Computer());
        b.buy(new Audio());

        System.out.println("remain : " + b.money);
        System.out.println("bonus : " + b.bonusPoint);
    }
}

class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price = price;
        bonusPoint = (int)(price/10.0);
    }
}

class Tv extends Product{
    Tv(){
        super(100);
    }
    public String toString() {return "Tv";}
}

class Computer extends Product{
    Computer(){
        super(200);
    }
    public String toString() {return "Computer";}
}

class Audio extends Product{
    Audio() {super(50);}
    public String toString() {return "Audio";}
}

class Buyer {
    int money = 1000;
    int bonusPoint = 0;
    Product[] item = new Product[10];
    int i = 0;

    void buy(Product p) {
        if (money < p.price) {
            System.out.println(" 잔액부족");
            return;
        }

        this.money -= p.price;
        this.bonusPoint += p.bonusPoint;
        item[i++] = p;
        System.out.println(p + " 구입");
    }

    void summary(){
        int sum = 0;
        String itemList ="";

        for (int i= 0; i< item.length; i++){
            if(item[i] == null) break;
            sum += item[i].price;
            itemList += item[i] + ", ";
        }
        System.out.println(sum);
        System.out.println(itemList);
    }
}
```

배열의 크기를 10으로 하면 11개 이상의 데이터를 받을 수 없는데, 그렇다고 해서 배열의 크기를 무조건 크게 설정할 수 만도 없다.

이때 Vector클래스를 사용한다.

Vector클래스는 내부적으로 Object타입의 배열을 가지고 있어서, 이 배열에 객체를 추가하거나 제거할 수 있게 작성되어있다.

| 메서드 / 생성자 | 설명 |
| --- | --- |
| Vector() | 10개의 객체를 저장할수 있는 Vector인스턴스를 생성한다. 10개 이상의 인스턴스가 저장되면 자동적으로 크기가 증가한다.|
| boolean add(Object o) | Vector에 객체를 추가한다. 성공시 true, 실패시 false 반환. |
| boolean remove(Object o) | Vector에 저장되어있는 객체를 제거한다. 성공시 true, 실패시 false 반환 |
| boolean isEmpty() | Vector가 비어있는지 검사. |
| Object get(int index) | 비어있으면 true, 안비었으면 false |
| int size() | Vector에 저장된 객체의 개수 반환 |

```java
import java.util.*;

class CodeTest{
    public static void main(String[] args){
        Buyer b = new Buyer();
        Tv tv = new Tv();
        Computer com = new Computer(); //refund를 하기위해서는 객체가 필요하므로 b.buy(new Computer())를 쓸 수 없다.
        Computer com1 = new Computer();
        Audio audio = new Audio();

        b.buy(tv);
        b.buy(com);
        b.buy(com1);
        b.buy(audio);

        b.summary();
        b.refund(com);
        b.summary();

    }
}

class Product{
    int price;
    int bonusPoint;

    Product(int price){
        this.price = price;
        bonusPoint = (int)(price/10.0);
    }
}

class Tv extends Product{
    Tv(){
        super(100);
    }
    public String toString() {return "Tv";}
}

class Computer extends Product{
    Computer(){
        super(200);
    }
    public String toString() {return "Computer";}
}

class Audio extends Product{
    Audio() {super(50);}
    public String toString() {return "Audio";}
}

class Buyer {
    int money = 1000;
    int bonusPoint = 0;
    Vector item = new Vector();

    void buy(Product p) {
        if (money < p.price) {
            System.out.println(" 잔액부족");
            return;
        }

        this.money -= p.price;
        this.bonusPoint += p.bonusPoint;
        item.add(p); // Vector는 add를 사용한다.
        System.out.println(p + " 구입");
    }

    void summary() {
        int sum = 0;
        String itemList = "";

        if (item.isEmpty()) {
            System.out.println("제품없음");
        }

        for (int i = 0; i < item.size(); i++) { // Vector는 item.length가 아닌 size()를 사용한다.
            Product p = (Product) item.get(i); // 중요 Vector 그 자체가 아니라, Product 타입으로 형변환
            sum += p.price;
            itemList += (i == 0) ? "" + p : ", " + p;
        }
        System.out.println("구매한 물건 총금액 : "+ sum);
        System.out.println("구매한 물건들 : " + itemList);
    }

    void refund(Product p){
            if(item.remove(p)) {
                money += p.price;
                bonusPoint -= p.bonusPoint;
                System.out.println(p + " 반품");
            }else{
                System.out.println(" 제품없음");
        }
    }
}
```

## 추상클래스(Abstract Class)

### 추상클래스란?

추상클래스는 미완성 설계도이다.

클래스가 미완성이라는것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고있다는 의미이다.

미완성 설계도로 완성된 제품을 만들수 없듯이 추상클래스로 인스턴스는 생성할 수 없다.

`추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.`

추상클래스는 추상메서드를 포함하고 있다는것을 제외하고는 일반클래스와 전혀 다르지 않다.

추상클래스에도 생성자가 있으며 멤버변수와 메서드도 가질 수 있다.

왜 사용하는거지?

같은 Tv라도 여러 종류의 모델이 있다. 사실 이 들의 설계도는 아마 90%정도는 동일할 것이다.

서로 다른 설계도를 그리는것보다는 이들의 공통부분만을 그린 미완성 설계도를 만들어 놓고,

미완성 설계도를 이용해서 각각의 설계도를 완성하는 것이 훨씬 효율적이기 때문이다.

### 추상메서드(Abstract Method)

추상의 정의 : 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신작용.

추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업

구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

```java
abstract class Player{
    boolean pause;
    int currentPos;

    Player(){
        pause = false;
        currentPos = 0;
    }
    /* 지정된 위치(pos)에서 재생을 시작하는 기능이 수행되도록 작성할것. */
    abstract void play(int pos);
    /* 재생을 즉시 멈추는 기능이 수행되도록 작성할것. */
    abstract void stop();
    void play(){
        play(currentPos);
    }
    void pause(){
        if(pause){
            pause = false;
            play(currentPos);
        } else {
            pause = true;
            stop();
        }
    }
}

class AudioPlayer extends Player{
    void play(int pos){}
    void stop() {}
}

abstract class AbstractPlayer extends Player{
    void player(int pos) {}
}
```

추상클래스를 상속받는 자손 클래스는 조상의 추상메서드를 상황에 맞게 적절히 구현해주어야한다.

자손 클래스에서 오버라이딩하여 자신의 클래스에 맞게 구현할 테니 추상메서드로 선언하는 것과 내용없는 빈 몸통만 만들어 놓는 것이나 별 차이가 없어보인다.

그래도 굳이 abstract를 붙여서 추상메서드로 선언하는 이유는 `자손클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.`

즉, 다시말해서 한번더 각인 시키기 위해서다.

추상 메서드로 정의되어 있지 않고 위와 같이 빈 몸통만 가지도록 정의되어있다면, 상속받는 자손 클래스에서는 이 메서드들이 온전히 구현된것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하는것을 잊을수도 있기 떄문이다.

abstract를 사용해 추상메서드로 정의해놓으면, 자손 클래스를 작성할때 이들이 추상메서드 이므로 내용을 구현해 주어야한다는 사실을 인식하고 자신의 클래스에 맞게끔 구현할 수 있다.

## 인터페이스(interface)

### 인터페이스란?

인터페이스는 일종의 추상클래스이다.

인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.

`오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그외의 다른 어떠한 요소도 허용되지 않는다.`

```java
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```

- 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야하며, 이를 생략할 수 있다. (단, static메서드와 default메서드는 예외(jdk1.8부터)

`인터페이스에 정의된 모든 멤버에 예외없이 적용되는 사항이기 때문에 제어자를 생략할 수 있는 것이며, 편의상 생략하는 경우가 많다.`

생략된 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다.

```java
interface PlayingCard{
    public static final int SPADE = 4;
    final int DIAMOND = 3; // public static final int DIAMOND = 3;
    static int HEART = 2; // public static final int HEART = 2;
    int CLOVER = 1; // public static final int CLOVER = 1;

    public abstract String getCardNumber();
    String getCardKind(); //public abstract String getCardKind();
}
```

원래는 인터페이스의 모든 메서드는 추상메서드이어야 하는데, jdk1.8부터 인터페이스에 static 메서드와 default메서드의 추가를 허용하는 방향으로 변경되었다.

실무에서는 아직 JDK1.8을 사용하지 않는 곳이 많기 때문에, JDK1.8이전의 규칙과 이후의 규칙을 모두 알고 있어야한다.

### 인터페이스의 상속

인터페이스는 인터페이스로부터만 상속 받을 수 있으며, 클래스와는 달리 다중상속,

즉, 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.

```java
interface Movable{
    /* 지정된 위치(x,y)로 이동하는 메서드 */
    void move(int x,int y);
}

interface Attackable{
    /* 지정된 대상(u)를 공격하는 메서드 */
    void attack(Unit u);
}
interface Fightable extends Movable, Attackable{ }
```

인터페이스는 클래스와 달리 Object 클래스와 같은 최고 조상이 없다.

### 인터페이스의 구현

인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야한다.

그 방법은 추상클래스가 자신을 상속받는 클래스를 정의하는 것과 다르지 않다.

클래스는 확장한다는 의미의 키워드 ‘extends’를 사용하지만 인터페이스는 구현한다는 의미의 키워드 ‘implements’를 사용할 뿐이다.

```java
class Fighter implements Fightable{
    public void move(int x, int y) {}
    public void attack(Unit u) {}
}
```

“Fighter 클래스는 Fightable을 구현한다”라고 표현함.

만일 구현 하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야한다.

```java
abstract class Fighter extends Unit implements Fightable {
    public void move(int x, int y) {}
    public void attack(Unit u) {}
}
```

다음과 같이 상속과 구현을 동시에 할 수도 있다.

이름이 ‘able’로 끝나는것은 Code Convention으로 인터페이스라는것으로 추측할수 있게 하기 위함이다.

```java
class FighterTest {
    public static void main(String[] args) {
        Fighter f = new Fighter();

        if (f instanceof Unit)
            System.out.println("f is descendant of the Unit class");

        if (f instanceof Fightable)
            System.out.println("f implements Fightable interface");

        if (f instanceof Movable)
            System.out.println("f implements Fightable interface");

        if(f instanceof Attackable)
            System.out.println("f implements Attackable interface");

        if(f instanceof Object)
            System.out.println("f is a descendant of the Object");
    }
}

class Fighter extends Unit implements Fightable{
    public void move(int x, int y) {}
    public void attack(Unit u) {}
}

class Unit{
    int currentHP;
    int x;
    int y;
}

interface Fightable extends Movable, Attackable {}
interface Movable { void move(int x, int y);}
interface Attackable {void attack(Unit u);}
```

![Untitled 2](https://user-images.githubusercontent.com/70310271/168278857-3baf2582-0cbf-4d45-a1f9-75f2a31c1a3b.png)

구조를 그려보니, Unit클래스의 멤버들과 같이 반드시 필요한 경우에는 상속으로 받아야하고,

반드시 추가할 필요가 없을때는 인터페이스로 만들어 구현하는 방식으로 사용할때 이 방식을 사용한다.

여기서 주의깊게 봐두어야 할 것은 Movable인터페이스에 정의된 ‘void move(int x, int y)’를 Fighter 클래스에서 구현할 때 접근 제어자를 public으로 했다는것이다.

interface Movable { void move(int x, int y);} 이렇게 정의되어있지만

사실 ‘public abstract’가 생략된 것이기 때문에 실제로 ‘public abstract void move(int x, int y)이다.

그래서 이를 구현하는 Fighter클래스에서는 반드시 public으로 해야하는것이다.

다시 복습) f instaceof Unit은 f가 Unit을 인스턴스로 가진다는 의미이다.

### 인터페이스를 이용한 다중상속

C++에서는 다중상속을 허용하기 때문에 자바는 다중상속을 허용하지 않는다는 것이 단점으로 부각되는것에 대한 대응으로 ‘자바도 인터페이스를 이용하면 다중상속이 가능하다.’ 라고 하는 것일 뿐 `자바에서 인터페이스로 다중상속을 구현하는 경우는 거의 없다.`

두 개의 클래스로 부터 상속을 받아야 할 상황이라면, 두 조상클래스 중에서 비중이 높은 쪽을 선택하고 다른 한쪽은 클래스 내부에 멤버로 포함시키는 방식으로 처리하거나 어느 한쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현한다.

```java
public class Tv{
    protected boolean power;
    protected int channel;
    protected int volume;

    public void power() {}
    public void channelUp() {}
    public void channelDown() {}
    public void volumeUp() {}
    public void volumeDown() {}
}

public class VCR{
    protected int counter;
    public void play() {}
    public void stop() {}
    public void reset() {}
    public int getCounter(){return counter;}
    public void setCounter(int c){counter = c;}
}
```

Tv클래스를 메인으로 가져가고 VCR클래스에 정의된 메서드와 일치하는 추상메서드를 갖는 인터페이스를 작성한다.

```java
public class Tv{
    protected boolean power;
    protected int channel;
    protected int volume;

    public void power() {}
    public void channelUp() {}
    public void channelDown() {}
    public void volumeUp() {}
    public void volumeDown() {}
}

public class VCR{
    protected int counter;
    public void play() {}
    public void stop() {}
    public void reset() {}
    public int getCounter(){return counter;}
    public void setCounter(int c){counter = c;}
}

public interface IVCR {
    public void play();
    public void stop();
    public void reset();
    public int getCounter();
    public void setCounter(int c);
}

public class TVCR extends Tv implements IVCR{
    VCR vcr = new VCR();

    public void play(){
        vcr.play(); // 새로작성하지 않고 VCR인스턴스의 메서드를 호출한다.
    }
    public void stop(){
        vcr.stop();
    }
    public void reset(){
        vcr.reset();
    }
    public int getCounter(){
        return vcr.getCounter();
    }
    public void setCounter(int c){
        vcr.setCounter(c);
    }
}
```

IVCR인터페이스를 구현하기 위해 새로 메서드를 작성해야하는 부담이 있지만, 그나마, VCR클래스의 인스턴스를 사용하면 조금 더 쉽게 다중상속을 구현할 수 있다.

### 인터페이스를 이용한 다형성

인터페이스 역시 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다.

인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter인스턴스를 Fightable타입의 참조변수로 참조하는 것이 가능하다.

```java
Fightable f = (Fighterable) new Fighter();
Fightable f = new Fighter();
```

따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다.

인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 것이다.

```java
void attack(Fightable f){}

class Fighter extends Unit implements Fightable{
    public void move(int x,  int y);
    public void attack(Fightable f);
}
```

다음과 같이 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것 역시 가능하다.

```java
Fightable method(){
    Fighter f = new Fighter();
    return f;
}
```

리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는것을 의미한다.

```java
interface Parseable{
    public abstract void parse(String fileName);
}

class ParserManager {
    public static Parseable getParser(String type){
        if(type.equals("XML")){
            return new XMLParser();
        } else {
            return new HTMLParser();
        }
    }
}

class XMLParser implements Parseable{
    public void parse(String fileName){
        System.out.println(fileName + " XML parsing completed");
    }
}

class HTMLParser implements Parseable{
    public void parse(String fileName){
        System.out.println(fileName + " HTML parsing completed");
    }   
}
```

매개변수로 넘겨받는 type의 값에 따라 XMLParser인스턴스 또는 HTMLParser인스턴스를 반환한다.

### 인터페이스의 장점

1. 개발시간을 단축 시킬 수 있다. (이해 못함)
    - 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다.
    - 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면되기 때문
    - 그리고 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 하면, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.
    
2. 표준화가 가능하다.
    
    기본틀을 인터페이스로 작성하고, 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
    
3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
    
    서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.
    
    ```java
    class RepairableTest{
        public static void main(String[] args){
            Tank tank = new Tank();
            Dropship dropship = new Dropship();
            Marine marine = new Marine();
            SCV scv = new SCV();
    
            scv.repair(tank);
            scv.repair(dropship);
        }
    }
    
    interface Repairable {}
    
    class Unit{
        int hitPoint;
        final int MAX_HP;
        Unit(int hp){
            MAX_HP = hp;
        }
    }
    
    class GroundUnit extends Unit{
        GroundUnit(int hp){
            super(hp);
        }
    }
    
    class AirUnit extends Unit{
        AirUnit(int hp){
            super(hp);
        }
    }
    
    class Tank extends GroundUnit implements Repairable{
        Tank(){
            super(150);
            hitPoint = MAX_HP;
        }
    
        public String toString(){
            return "Tank";
        }
    }
    
    class Dropship extends AirUnit implements Repairable{
        Dropship(){
            super(125);
            hitPoint = MAX_HP;
        }
        public String toString(){
            return "Dropship";
        }
    }
    
    class Marine extends GroundUnit{
        Marine(){
            super(40);
            hitPoint = MAX_HP;
        }
    }
    
    class SCV extends GroundUnit implements Repairable{
        SCV() {
            super(60);
            hitPoint = MAX_HP;
        }
    
        void repair(Repairable r){
            if(r instanceof Unit){
                Unit u = (Unit)r;
                while(u.hitPoint != u.MAX_HP){
                    u.hitPoint++;
                }
                System.out.println(u.toString() + " 수리끝");
            }
        }
    }
    ```
    
    ```java
    void repair(Tank t) {}
    void repair(Dropship d) {}
    
    // 갯수 만큼 수리 구현? 비효율
    
    void repair(GroundUnit gu) {}
    void repair(AirUnit au) {}
    
    // 그렇다고 공통조상의 타입으로 메서드를 정의해도 기계화 유닛이 아닌 클래스도 포함될수 있기 때문에 불가능
    ```
    
    인터페이스를 활용하여, 서로 관계 없던 클래스끼리의 관계를 만들어 사용할 수 있게 만든다.
    
    Unit u = (Unit)r; → 인자로 받아온 Repairable에는 정의된 멤버가 없다. 그래서, Unit클래스로 캐스팅 해주어야만, 정의된 hitPoint와 MAX_HP를 사용할 수 있다.
    
4. 독립적인 프로그램이 가능하다.
    
    인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.
    
    클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.
    

### 인터페이스의 이해

인터페이스의 규칙이나 활용이 아닌, 본질적인 측면에 대해 알아보자.

- 클래스를 사용하는 쪽(User)와 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(provider)의 선언부만 알면 된다. (내용은 몰라도 된다.)

```java
class A{
public void methodA(B b) {
    b.methodB();
    }
}

class B{
    public void methodB(){
        System.out.println("methodB()");
    }
}

class InterFaceTest{
    public static void main(String args[]){
        A a = new A();
        a.methodA(new B());
    }
}
```

메서드 A를 실행시키기 위해서는 메서드 B가 필요하다.

하지만 클래스 B가 변경되면 메인함수의 내용을 바꾸어주어야한다.

```java
interface I{
    public abstract void methodB();
}

class B implements I{
    public void methodB(){
        System.out.println("methodB in B class");
    }
}

class A{
    public void methodA(I i){
        i.methodB();
    }
}
```

인터페이스로 정의를 해둔다면, 클래스 B를 호출하지 않아도 된다.

클래스 A는 여전히 클래스 B의 메서드를 호출하지만, A는 인터페이스 I와 관계가 있기 떄문에 `클래스 B의 변경에 영향을 받지 않는다.`

클래스 A는 인터페이스를 통해 실제로 사용하는 클래스의 이름을 몰라도 되고 심지어는 실제로 구현된 클래스가 존재하지 않아도 문제가 되지 않는다.

즉, `오직 클래스 A는 관계가 있는 인터페이스 I의 영향만 받는다.`

이것이 인터페이스의 본질이다.

클래스 Thread의 생성자인 Thread(runnable target)이 이런 방식으로 되어있다.

이처럼 매개변수를 통해 동적으로 제공받을 수 도 있지만 다음과 같이 제3의 클래스를 통해서 제공받을 수도 있다.

JDBC의 DriverManager클래스가 이런 방식으로 되어있다.

```java
class A {
    void methodA() {
        I i = InstanceManager.getInstance();
        i.methodB();
        System.out.println(i.toString()); // i로 Object의 메서드 호출가능
    }
}

interface I {
    public abstract void methodB();
}

class B implements I {
    public void methodB(){
        System.out.println("methodB in B class");
    }
    
    public String toString() {return "class B";}
}

class InstanceManager{
    public static I getInstance(){
        return new B(); // 다른 인스턴스로 바꾸려면 이 부분만 변경 해주면됨.
    }
}
```

이 방식을 택하면, A클래스를 바꿀 필요없이 GetInstace()만 변경하면 된다는 장점이 있다.

그리고 인터페이스 타입의 참조변수로도 Object클래스에 정의된 메서드들을 호출할 수 있다.

### default메서드와 static메서드

원래는 인터페이스에 추상 메서드만 선언할 수 있는데, JDK1.8부터 디폴트 메서드와 static메서드도 추가할 수 있게 되었다. `static메서드는 인스턴스와 관계가 없는 독립적인 메서드이기 때문`에 예전부터 인터페이스에 추가하지 못 할 이유가 없었다.

인터페이스에 메서드를 추가한다는 것은, 추상 메서드를 추가한다는 것이고, 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야한다.

JDK의 설계자들은 고심 끝에 디폴트 메서드(defualt method)를 고안했다.

디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.

조상 클래스에 새로운 메서드를 추가한것과 동일해 지는것이다.

```java
interface MyInterface{
    void method();
    void newMethod();
}

->

interface MyInterface2{
    void method();
    default void newMethod() {};
}
```

디폴트 메서드는 앞에 키워드 default를 붙이며, `추상 메서드와 달리 일반 메서드처럼 몸통{}이 있어야한다.`

디폴트 메서드 역시 접근제어자가 public이며, 생략이 가능하다.

이름이 중복되어 충돌하는 경우 어떻게 대처할것인가?

1. 여러 인터페이스의 디폴트 메서드 간의 충돌
- 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.

1. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
- 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.

그냥 간단히 필요한 메서드의 내용으로 오버라이딩 하면 끝이다.
