# 입출력장치

## 장치 컨트롤러와 장치 드라이버

### Device Controller(장치 컨트롤러)

입출력 장치는 장치가 너무 다양해서 속도, 데이터, 전송형식도 다양하다.

당연하게도 다양한 입출력장치와 정보를 주고받는 방식을 규격화하기 어렵다.

일반적으로 CPU와 메모리 데이터의 전송률은 높지만, 입출력장치의 데이터 전송률은 낮다.

여기서 전송률(Transfer Rate)란?

데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표이다.

CPU와 메모리처럼 전송률이 높은 장치는 1초에도 수많은 데이터를 주고받을 수 있지만 키보드와 마우스와 같이 상대적으로 전송률이 낮은 장치는 같은 시간 동안 데이터를 조금씩만 주고받을 수 있다.

이렇듯 전송률의 차이는 CPU와 메모리, 입출력장치간의 통신을 어렵게한다.

물론 어떤 입출력장치는 CPU나 메모리보다 전송률이 높은 경우도 있다.

하지만 결과적으로 CPU나 메모리와 전송률이 비슷하지 않기 때문에 같은 어려움을 겪게된다.

이와 같은 이유로 입출력장치는 컴퓨터에 직접 연결되지 않고 장치 컨트롤러(Device Controller)라는 하드웨어를 통해 연결된다.

장치 컨트롤러는 I/O Controller(입출력 제어기), I/O Module(입출력 모듈)등으로 다양하게 불리기도 한다.

모든 입출력장치는 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 정보를 주고받고, 장치 컨트롤러는 하나 이상의 입출력장치와 연결되어 있다.

하드디스크 또한 장치 컨트롤러가 있다.

장치 컨트롤러는 대표적으로 3가지 역할을 한다.

1. CPU와 입출력장치 간의 통신 중개
2. 오류 검출
3. 데이터 버퍼링

입출력 장치 종류가 많아 정보 규격화가 어려웠던 문제는 장치 컨트롤러가 일종의 번역가 역할을 함으로써 해결할 수 있다.

그 과정에서 장치 컨트롤러는 자신과 연결된 입출력장치에 문제는 없는지 오류를 검출하기도한다.

- 데이터 버퍼링이란?

전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 Buffer라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법이다.

![Untitled](https://user-images.githubusercontent.com/70310271/211202868-3df1cb7a-0344-419e-a304-07b735259a04.png)

1. 버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보낸다.
2. 데이터를 한번에 많이 받아 조금씩 내보낸다.

장치 컨트롤러는 일반적으로 전송률이 높은 CPU와 일반적으로 전송률이 낮은 입출력장치와의 전송률 차이를 데이터 버퍼링으로 완화된다.

장치 컨트롤러의 내부를 살펴보자.

![Untitled 1](https://user-images.githubusercontent.com/70310271/211202886-8d17c778-a205-4ba6-a1e0-d0f6b015ecb8.png)

- 데이터 레지스터

데이터 레지스터는 CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터이다.

데이터 레지스터가 전송률 완화를 위한 버퍼역할을 한다.

최근 주고받는 데이터가 많은 입출력장치에서는 레지스터 대신 RAM을 사용하기도 한다.

- 상태 레지스터

상태 레지스터에는 입출력장치가 입출력 작업을 할 준비가 되어있는지, 입출력 작업이 완료되었는지, 입출력 장치에 오류는 없는지 등의 상태 정보가 저장된다.

- 제어 레지스터

입출력장치가 수행할 내용에 대한 제어정보와 명령을 저장한다.

feat) 상태 레지스터와 제어 레지스터는 하나의 레지스터(상태/제어 레지스터)로 사용되기도 한다.

이 레지스터들에 담긴 값들은 버스를 타고 CPU나 다른 입출력장치로 전달되기도 하고, 장치 컨트롤러에 연결된 입출력장치로 전달된다.

입출력 장치 안에도 Device Controller가 있을수 있다.

[디바이스 컨트롤러, 디바이스 드라이버, ssd 컨트롤러란? 개념 정리](https://melonicedlatte.com/computerarchitecture/2020/01/01/234600.html)

### Device Driver (장치 드라이버)

장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램

컴퓨터가 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 그 장치는 어떤 회사에서 만들어진 제품이든, 생김새가 어떻든 상관없이 컴퓨터 내부와 정보를 주고받을 수 있다.

반대로 장치 드라이버를 인식하거나 실행할 수 없는 상태라면 그 장치는 컴퓨터 내부와 정보를 주고받을 수 없다.

장치 드라이버를 인식하고 실행하는 주체는 정확히는 운영체제이다.

운영체제가 장치 드라이버를 인식하고 실행할 수 있다.

장치 드라이버는 운영체제가 기본적으로 제공하는것도 있지만, 장치 제작자가 따로 제공하기도 한다.

이땐 직접 해당 드라이버를 설치해야만 사용이 가능하다.

## 다양한 입출력 방법

입출력 작업을 수행하려면 CPU와 장치컨트롤러가 정보를 주고 받아야한다.

어떻게 장치 컨트롤러는 CPU와 정보를 주고 받을까?

크게 3가지 방법이 있다.

1. 프로그램 입출력
2. 인터럽트 기반 입출력
3. DMA 입출력

### 프로그램 입출력(Programmed I/O)

기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법

CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력 장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다.

ex) 메모리에 저장된 정보를 하드 디스크에 백업하는 상황

1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 WRITE 명령을 보낸다.

![Untitled 2](https://user-images.githubusercontent.com/70310271/211202900-2e101adc-8a66-4e55-934f-5ac7421eb1c5.png)


2. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인한다. 
하드 디스크가 준비된 상태라면 하드 디스크 컨트롤러는 상태 레지스터에 준비되었다고 표시한다.

![Untitled 3](https://user-images.githubusercontent.com/70310271/211202915-f393a416-7f46-4960-9c16-98d74c90d2f9.png)


3. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인한다.

![Untitled 4](https://user-images.githubusercontent.com/70310271/211202925-7b9efd5e-88e1-4834-bb00-d78523066264.png)


1. 하드 디스크가 준비 됐음을 CPU가 알게 되면 백업할 메모리의 정보를 데이터 레지스터에 쓴다.
2. 아직 쓰기 작업이 끝나지 않았다면 1번 부터 반복하고, 쓰기가 끝났다면 작업을 종료한다.

CPU는 장치 컨트롤러의 레지스터 값을 읽고 쓴다.

어떻게 CPU는 입출력장치들의 주소를 알 수 있을까?

분명 아래와 같은 과정이 있을것이다.

프린터 컨트롤러의 상태 레지스터를 읽어라.

프린터 컨트롤러의 데이터 레지스터에 100을 써라.

키보드 컨트롤러의 상태 레지스터를 읽어라.

하드 디스크 컨트롤러의 데이터 레지스터에 ‘a’를 써라.

이렇게 CPU가 장치 컨트롤러의 레지스터를 알기 위한 방법에는 2가지 방법이 있다.

### Memory Mappped I/O(메모리 맵 입출력)

메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법.

![Untitled 5](https://user-images.githubusercontent.com/70310271/211202942-e564619c-fd7f-4ea9-8c96-685ac69a2682.png)

512개는 메모리 주소, 또 나머지 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용한다.

CPU는 “513번지를 읽어 들여라”라는 명령어로 프린터의 상태를 읽을 수 있다.

그리고 “514번지에 ‘a’를 써라” 명령어로 하드 디스크 컨트롤러의 데이터 레지스터로 데이터를 보낼 수 있다.

이때 중요한점은 메모리 맵 입출력 방식에서 `CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다`는 점이다.

메모리에 접근하는 명령어와 입출력 장치에 접근하는 명령어가 굳이 다를 필요가 없다.

### Isolated I/O (고립형 입출력)

메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법이다.

`CPU는 입출력 장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른` 입출력 읽기/쓰기 선을 활성화 시키는) 입출력 명령어를 사용한다.

메모리 맵 입출력 처럼 제어버스에 ‘메모리 읽기/쓰기’ 선 만 있는게 아니라,

‘메모리 읽기 쓰기’선 이외에 ‘입출력장치 읽기/쓰기’선도 따로 놓아 메모리를 위한 주소공간과, 입출력 장치를 위한 주소 공간을 따로 둔다.

![Untitled 6](https://user-images.githubusercontent.com/70310271/211202954-3bdb6073-fb71-4f60-a740-be66adee2ad3.png)

CPU가 메모리 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 메모리에 접근하고, 입출력 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 장치 컨트롤러에 접근한다.  

![Untitled 7](https://user-images.githubusercontent.com/70310271/211202961-f7d5269b-6af6-440c-a5c6-2dc5dfdb2223.png)

### Interrupt-Driven I/O (인터럽트 기반 입출력)

하드웨어 인터럽트는 정확히 말하면 입출력장치가 아닌 장치 컨트롤러에 의해 발생한다.

우선 CPU는 장치 컨트롤러에 입출력 작업을 명령한다.

그러고 나면 장치 컨트롤러가 입출력장치를 제어하며 입출력을 수행하는 동안 CPU는 다른일을 하는것이다.

![Untitled 8](https://user-images.githubusercontent.com/70310271/211202967-a0c9be02-17d1-4a49-b2b0-68389651fa73.png)

장치 컨트롤러가 입출력 작업을 완료한 뒤에 CPU에게 인터럽트 요청 신호를 보내면 이제서야 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행하는것이다.

- Polling

인터럽트와 비교되는 개념 중 하나이다.

CPU는 주기적으로 장치 컨트롤러의 상태 레지스터를 확인하며 입출력장치의 상태를 확인한다.

이처럼 폴링이란 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지를 주기적으로 확인하는 방식이다.

폴링 방식은 당연하게도 인터럽트 방식보다 CPU의 부담이 더 크다.

인터럽트를 활용하면 CPU가 인터럽트 요청을 받을 때까지 온전히 다른 일에 집중할 수 있기 때문이다.

사전적 정의

**폴링**
(polling)이란 하나의 장치(또는 프로그램)가 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다.

### 여러 입출력장치에서 인터럽트가 동시에 발생하면 어떻게 처리할까?

간단히 생각하면 인터럽트가 발생한 순서대로 인터럽트를 처리할 수 있다.

ex) 인터럽트 A를 처리하는 도중 발생한 인터럽트 B의 요청을 받아 들이지 않고,

인터럽트 A 서비스 루틴이 끝나면 그때 비로소 인터럽트 B 서비스 루틴을 실행한다.

![Untitled 9](https://user-images.githubusercontent.com/70310271/211202976-f79ac58b-5a9f-4968-b8d1-64f910ee8f0a.png)

하지만 현실적으로 모든 인터럽트를 전부 순차적으로만 해결할 수는 없다.

인터럽트 중에서도 더 빨리 처리해야하는 인터럽트도 있기 때문이다.

`CPU는 인터럽트 간에 우선 순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리할 수 있다.`

![Untitled 10](https://user-images.githubusercontent.com/70310271/211202983-384f7a07-d32e-4ab5-bc9a-12d7a1c1e50b.png)

현재 CPU가 인터럽트 A를 처리하는 도중에 인터럽트 B가 발생했을때,

만약 인터럽트 B의 우선순위가 더 높다면, A의 실행을 잠시 멈추고, 인터럽트 B를 처리한 뒤 다시 A를 처리한다.

좀 더 구체적으로는,

1. 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우
2. 인터럽트 비트를 비 활성화해도 무시할 수 없는 인터럽트 NMI(Non Maskable Interrupt)가 발생한 경우

CPU는 우선순위가 높은 인터럽트부터 처리한다.

우선순위를 반영하여 다중 인터럽트를 처리하는 방법에는 여러 가지가 있지만, 많은 컴퓨터에서는 “Programmable Interrupt Controller”(프로그래머블 인터럽트 컨트롤러 : PIC)라는 하드웨어를 사용한다.

PIC는 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야할 하드웨어 인터럽트는 무엇인지 알려주는 장치이다.

PIC에는 여러 핀이 있는데, CPU에 하드웨어 인터럽트 요청을 보낼 수 있는 약속된 하드웨어가 연결되어있다.

ex) PIN1 → Timer Interrupt , PIN2 → KeyBoard Interrupt

PIC에 연결된 장치 컨트롤러들이 동시에 하드웨어 인터럽트 요청을 보내면 PIC는 이들의 우선순위를 판단하여 CPU에 가장 먼저 처리할 인터럽트를 알려준다.

![Untitled 11](https://user-images.githubusercontent.com/70310271/211202994-a901e96c-a801-427c-a7fb-b289220a5123.png)

1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호(들)을 받아들인다.
2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다.
3. CPU는 PIC에 인터럽트 확인 신호를 보낸다.
4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다.
5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게되고, 해당 장치의 인터럽트 서비스 루틴을 실행한다.

PIC가 우선 순위를 조정해 주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트이다. 

![Untitled 12](https://user-images.githubusercontent.com/70310271/211203002-92195b12-39c5-4958-917f-6db033003a34.png)

일반적으로 더 많고 복잡한 장치들의 인터럽트를 관리하기 위해 PIC를 두 개 이상 계층적으로 구성한다.

이렇게 PIC를 여러 개 사용하면 훨씬 더 많은 하드웨어 인터럽트를 관리할 수 있다.

feat)

PIC가 우선 순위를 조정해 주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트이다.

PIC가 무시할 수 없는 인터럽트인 NMI까지 우선순위를 판별하지는 않는다.

NMI는 우선순위가 가장 높아 우선순위 판별이 불필요하기 때문이다.

### DMA 입출력

프로그램 기반 입출력과 인터럽트 기반 입출력에 공통점이 있다면

입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다는점이다.

입출력장치 데이터를 메모리에 저장하는 경우 CPU는 장치 컨트롤러에서 입출력 장치 데이터를 하나씩 읽어 레지스터에 적재하고, 적재한 데이터를 메모리에 저장한다.

![Untitled 13](https://user-images.githubusercontent.com/70310271/211203021-633fd606-3d04-489d-83fd-e7a10a9b5bf8.png)

메모리속 데이터를 입출력 장치에 내보내는 경우에도 마찬가지이다.

CPU는 메모리에서 데이터를 하나씩 읽어 레지스터에 적재하고, 적재한 데이터를 하나씩 입출력 장치에 내보낸다.

![Untitled 14](https://user-images.githubusercontent.com/70310271/211203029-d37ee19a-c86b-4cbb-a8c0-6e6e2baae624.png)

입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 가뜩이나 바쁜 CPU는 입출력장치를 위한 연산 때문에 시간을 뺏기게 된다.

하드 디스크 백업과 같이 대용량 데이터를 옮길 때는 CPU 부담이 더욱 커진다.

그래서 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식인 DMA(Direct Memory Access)가 등장했다.

DMA는 직접 메모리에 접근할 수 있는 입출력 기능이다.

DMA 입출력을 하기 위해서는 시스템 버스에 연결된 DMA 컨트롤러 라는 하드웨어가 필요하다.

- DMA 입출력 과정
1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산(읽기/쓰기), 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령한다.

![Untitled 15](https://user-images.githubusercontent.com/70310271/211203039-d905e920-1b6c-4914-a7ac-f7d14a315876.png)

1. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다.

이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.

![Untitled 16](https://user-images.githubusercontent.com/70310271/211203041-c3eeb8c0-1bf3-4fb4-b237-291f6caaeea5.png)

1. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알린다.

![Untitled 17](https://user-images.githubusercontent.com/70310271/211203054-7e4521be-4c28-464d-927c-fc89976d46a5.png)

입출력장치와 메모리 사이에 주고받을 데이터는 CPU를 거치지 않는다.

CPU는 DMA 컨트롤러에게 입출력 작업 명령을 내리고, 인터럽트만 받으면 된다.

`하지만 문제가 있다.`

DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근이 가능하지만, 시스템 버스는 동시 사용이 불가능하다.

시스템 버스는 공용자원이기 때문이다.

CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없고, DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU가 시스템 버스를 사용할 수 없다.

1. CPU가 시스템 버스를 이용하지 않을 떄마다 조금씩 시스템 버스를 이용한다.
2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용한다.

CPU 입장에서는 마치 버스에 접근하는 주기를 도둑 맞는 기분이 들것이다.

이러한 DMA의 시스템 버스 이용을 “Cycle Stealing”(사이클 스틸링)이라고 부른다.

- 입출력 버스

DMA 컨트롤러와 장치 컨트롤러의 연결 방식과 입출력 버스에 대해 알아보자.

CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하는 구성에서는 DMA를 위해 한번 메모리에 접근할 때마다 시스템 버스를 두 번 사용하게 되는 부작용이 있다.

![Untitled 18](https://user-images.githubusercontent.com/70310271/211203058-e017b640-63d8-484a-b903-9b37b088abcb.png)

메모리에서 DMA 컨트롤러로 데이터를 가져오기 위해 시스템 버스를 한 번 사용하고, DMA 컨트롤러의 데이터를 장치 컨트롤러로 옮기기 위해 시스템 버스를 또 한 번 사용한다.

DMA를 위해 시스템 버스를 너무 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못한다. `이 문제를 해결하기 위해 입출력 버스를 사용한다.`

![Untitled 19](https://user-images.githubusercontent.com/70310271/211203063-d7f084d3-20b4-460d-b3f7-127c8640a5a7.png)

그림처럼 연결하여, DMA컨트롤러와 장치 컨트롤러가 서로 데이터를 전송할 때는 시스템 버스를 이용할 필요가 없으므로 시스템 버스의 사용 빈도를 줄일 수 있다.

현대 대부분 컴퓨터에는 입출력 버스가 있고, 대부분의 입출력장치(장치 컨트롤러)는 시스템 버스가 아닌 입출력 버스와 연결된다.

입출력 버스는 입출력장치를 컴퓨터 내부와 연결짓는 통로이다.

입출력 버스에는 PCI(Peripheral Component Interconnect) Bus, PCIe Bus 등 여러 종류가 있다.

feat) DMA를 통해 입출력장치와 메모리가 CPU를 거치지 않고 직접 데이터를 주고받을 수 있게 되었지만, `여전히 입출력 명령어를 인출하고, 해석하고, 실행하는 역할은 상당 부분 CPU의 몫`이었다.

그래서 최근에는 메모리에 직접 접근할 뿐만 아니라 입출력 명령어를 직접 인출하고, 해석하고, 실행까지 하는 일종의 입출력 전용 CPU가 만들어 졌는데, 이를 입출력 프로세서(IOP ; input/Output Processor) 혹은 입출력 채널(Input/Ouput Channel)이라고 부른다.

ex) CPU를 탑재한 삼성 레이저 프린터

입출력 채널이 있는 컴퓨터에서는 CPU가 입출력 명령어를 실행하지 않는다.

CPU가 입출력 채널에게 메모리에 저장된 특정 입출력 명령어를 수행하라고 지시하면, 입출력 채널은 해당 입출력 명령어를 인출하고, 해석하고, 실행한 뒤, 인터럽트를 통해 결과를 CPU에게 알린다.
