# 프로그래머의 뇌

프로그래밍을 하다보면 늘 혼란(Confusion)이 일어난다.

## 코드가 초래하는 세가지 종류의 혼란

### 혼란의 첫번째 유형 : 지식의 부족

```java
2 2 2 2 2 T n // APL(A Programming Language)
```

T가 뭔지몰라서 발생하는 오류.

언어나 알고리즘 또는 업무 영역에 대한 지식이 없는 경우 발생하는 혼란.

### 혼란의 두번째 유형 : 정보의 부족

```java
public class BinaryCaluclator{
    public static void main(Integer n){
        System.out.println(Integer.toBinaryString(n));
    }
}
```

이진수 표현으로 변환하는 부분은 인지할수 있지만, toBinaryString() 메서드가 내부적으로 어떻게 작동하는지 모른다면 이 코드도 혼란 스러울 수 있다.

코드를 이해하기 위해 필요한 정보를 가지고 있지 못한 경우 발생하는 혼란

### 혼란의 세번째 유형 : 처리 능력의 부족

```java
LET N2 = ABS(INT(N))
LET B$ = ""
FOR N1 = N2 TO 0 STEP 0
    LET N2 = INT(N1 / 2)
    LET B$ = STR$(N1 - N2 * 2) + B$
    LET N1 = N2
NEXT N1
PRINT B$
```

변수이름이나 연산자를 통해 코드가 무슨일을 하는지 유추할 수 있지만, 모든 과정을 처리하기는 어렵다.각각의 단계가 실행되는것을 한눈에 파악할 수 없기 떄문에 혼란스럽다.

처리 능력(Processing Power)이 부족하기 때문이다.

변수에 임시로 저장되는 값을 모두 기억하거나, 각각의 경우 어떤 동작들이 수행되는지 동시에 알기가 쉽지않다.

### 코딩에 영향을 주는 인지과정

지식이 없다는것은 두뇌의 장기 기억 공간(Long-term-memory,LTM)에 해당 내용이 없다는것을 뜻한다.

지식의 부족 = LTM의 문제

지식이 아닌 어떤 정보가 부족할때는 단기기억 공간(Short-term-memory,STM)에 대한 내용이 없기 때문이다.

정보의 부족 = STM의 문제

많은 정보를 처리할 떄는 작업기억공간(Working Memory)에 영향을 미치는데 우리는 사고할 때 이 영역을 사용한다.

처리능력의 부족 = 작업 기억 공간의 문제

### LTM과 프로그래밍

우리가 어떤 일을 할때든 LTM이 사용된다. 가령 신발 끈을 묶을 때 근육이 무엇을 해야 할지 자동으로 기억한다.

APL 예제 코드를 읽을때, LTM을 가장 많이 사용한다.

우리가 APL키워드의 T의 의미를 알고 있다면 코드를 읽을때 그것을 LTM으로부터 인출(retrieval)할 것이다.

이 예제로 언어의 문법에 대한 지식도 중요하단걸 알 수 있다.

### STM과 프로그래밍

누군가와 통화중에 전화번호를 알려줄때 이 번호는 LTM에 저장되지 않고 STM에 우선 저장된다. STM이 기억할 수 있는 항목의 최대치가 12개를 넘지 않는다는점에 대부분의 학자가 동의한다.

Integer n이라는 사실을 기억하며, 계속해서 코드를 읽어나가는것이다.

mian을 읽을 때 이것은 STM에 저장되지만, 이 함수명을 사용하는 대신 main이라고 하는, 과거의 경험으로 인해 이미 LTM에 저장되어 있는 이름을 사용한다. 이것은 두 가지 인지과정이 서로 독립적으로 일어나는것이 아니라는것을 보여준다.

### 작업 기억 공간과 프로그래밍

실제 사고 작용은 LTM이나 STM이 아닌 작업 기억 공간에서 일어난다

생각, 아이디어, 해결책 같은 것들이 여기에서 만들어진다.

LTM은 HDD, STM은 메인 메모리, 작업 기억공간은 두뇌의 프로세서라고 볼 수 있다.

우리 머리는 코드를 실행해보면서 무슨 일이 일어날지 이해하려 시도한다.

이 과정을 트레이싱(Tracing)[추적]이라고 부르는데, 

머릿속에서 코드를 컴파일하고 실행하는 과정을 의미한다.

변수의 값을 코드 내에 별도로 적어놓고 싶은 마음이 들수가 있는데,

이러한 현상은 작업기억 공간이 꽉차서 더 많은 저오를 처리할 수 없을 때 나타날 수 있다. (4장에서 정보 과부하상태, 예방법을 배운다.)

### 인지 과정들의 상호작용

1. LTM에서 관련된 지식을 인출하는가?
2. LTM에서 인출했다면, 어떤 정보를 가져왔는가?
3. STM에 정보를 저장하는가?
4. STM에 구체적으로 어떤 정보를 저장하는가?
5. 관련이 없어 보여 무시하고 넘어가는 정보는 없는가?
6. 코드의 특정 부분을 광범위하게 작업 기억 공간을 사용해서 분석하는가?
7. 코드의 어떤 부분이 작업 기억 공간에 과부하를 주는가?
8. 코드의 그 부분들이 작업 기억 공간을 어떻게 사용하는지 이해하는가?

O,오메가, f는 함수아닐까?,

O O O O X , O , 지식적인 부분 (삼각형),X

모호한 단어를 보면 작업 기억 공간이 활성화되어 문맥속에서 적합한 의미를 찾으려고 한다.

### 코드를 신속하게 읽기

프로그램은 사람이 읽을 수 있도록 작성해야만 한다.

### 전문가는 초보자보다 코드를 더 잘 기억한다.

핵심은 초보자들은 단어를 기억하기 쉽게 나열하는 방식을 사용하고

“True is Real Then False”

숙련된 개발자들은 단어를 쓰임새의 단위로 맞춰서 기억한다.

“True False Boolean” , “If Else Then”

질문하는것도 좋다. → 코드의 구조는 어떻게 되어 있는가?

깊이 중첩된 구조, 중첩이 없는 평탄구조?

눈에 띄는 라인은 없는가?

코드에서 들여쓰기는 어떻게 되어 있는가?

코드에 간격은 있는가?

코드에 큰 뭉치처럼 보이는건 없는가?

### 청크로 묶을 수 있는 코드를 작성하는 방법

1. 디자인 패턴을 배운다.

공과대학교 컴퓨터 과학교수인 Walter Tichy의 현직자 대상 실험

1. Martha Elizabeth Crosby 

코드에 주석문이 있으면 새로운 팀원이 코드를 쉽게 이해 할 수 있다.

1. 주석문은 개발자가 코드를 청킹하는 방식에도 영향을 미친다.

Quyin Fan의 2010년 메릴랜드 대학교 박사 학위 논문

“이 함수는 이진트리를 중위 순회하며 프린트한다.”

위와 같은 고수준 주석문은 코드를 청크 단위로 쪼개는 데 도움이 된다.

반면 i++; 다음에 i를 1만큼 증가 같은 저수준 주석문을 넣는 것은 오히려 청킹 작업에 부담이 된다

### 즉, 올바른 표식(Beacon)을 남겨라.

코드를 청크로 쉽게 쪼갤 수 있도록 하라.

ex) class Node:

def print_in_order

Root, Tree라는 변수명, 주석문에 단어 “Tree”사용

Left, Right라는 필드명

표식은 코드를 읽고 이해하는 과정에서 소스 코드에 대해 개발자가 갖는 가정이 맞거나 틀린 것을 확인해주는 역할을 수행하기 때문에 매우 중요하다.

Node 클래스를 본다 → “트리에 관한 것이다.” 추론 가능

Left, Right를 사용한다 → “이진트리에 관한 것이다.” 더 좁은 추론 가능

- 단순 표식

root, tree가 단순 표식에 해당한다.

+,>,&& 같은 연산자, if, else같은 구조문도 그 자체로 코드의 기능에 대해 코드를 읽는 개발자에게 알려주기 때문에 단순 표식이라고 볼 수 있다.

- 복합 표식

복합 표식은 단순 표식으로 이루어진 좀 더 큰 단위의 코드로, 단순 표식들이 모여 함께 실행하는 기능에 대해 알려준다.

Left, Right는 둘이 합쳐 하나의 복합 표식을 형성한다.

즉, 개별적으로는 별로 의미가 없으나 같이 보면 의미가 있다.

for와 같이 변수 선언, 초기화, 값의 변화, 경계조건을 모두 포함하기 때문에 복합 표식이다.

1. 코드 선정

잘 알지 못하는 코드베이스를 선택하되 자신이 잘 아는 언어로 된 코드를 선정한다.

1. 코드 파악

1단계에서 선택한 메서드나 함수를 파악하고 코드가 하는일을 요약한다.

## 코드를 더 깊이 있게 이해하기

## 변수 역할 프레임 워크

이스턴 핀란드 대학교의 Jorma Sajaniemi 교수는 11개의 역할로 대부분의 변수를 설명할 수 있다고 주장한다.

### 변수의 11가지 역할

1. Fixed Value(고정 값)
2. Stepper
3. Flag
4. Walker
5. Most Recent Holder
6. Most Wanted Holder
7. Gatherer
8. Container → ex) array, list, stack, tree 등
9. follower

이전 값 혹은 다음 값을 추적하기 위한용도 ex) 연결리스트 이전값에 대한 포인터

1. Organizer

추가 적인 처리를 위해 변수의 값을 변환함.

1. temporary

```java
if (변하지 않는 값인가?)
    1. 고정값

else if (임시 저장 장소 인가?)
    1. 컨테이너
    2. 조직자
    3. 임시

else if (검사를 해야 하는가?)
    1. 플래그

if (반복을 해야 하는가?)
    1. 워커
    2. 최근값 보유자
    if 계수인가?
        1. 스테퍼 ex) i=0
        2. 지연되는가? -> ex) 추적자
    if 축적되는가?
        1. 모집자
    if 골라야 하는가?
        1. 목적값 보유자
```

위와 같은 변수 역할 프레임워크를 사용하면 사용하지 않은 학생보다 성과가 더 뛰어난 것으로 알려져 있다.

Jorma Sajaniemi et al,. “An experiment on Using Roles of Variables in Teaching Introductory Programming”, (2007)

### 프로그램 이해의 여러 단계

1. 초점(Focal Point)을 찾는다.

Entry Point에 해당한다.

예를 들어서 설명하자면, API를 호출했을 때, 해당하는 API의 바디 부분을 의미한다고 생각하면 편하다.

ex) main()일수도 있고, API일 수도있고 다양하다.

1. 초점으로부터 지식을 확장한다.

API 바디에 있는 객체와 메서드의 내용들을 하나하나씩 보면서 이해한다.

1. 관련된 개체로 부터 개념을 이해한다.

1. 여러 개체에 걸쳐있는 개념을 이해한다.

### 수학보다 언어

Chnatal S. Prat et al, “Relating Natural Language Aptitude to Individual Differences in Learning Programming Langugaes” (2020).

계산능력, 수학적 능력을 적용해야 하는 지식과 기술은 프로그래밍 능력에 대한 예측력이 작았다.

실험 참여자들 사이에서 겨우 2%의 편차가 나타났다.

### 주석으로 모르는 부분 표시하기 (모니터링)

모르는 부분은 ?로 표시하고 아는 부분은 O로 표시한다.

처럼 기호로 표시해 둔다.

이 라인의 역할은 무엇인가?

이 라인은 프로그램의 전체 목적과 어떻게 관련되는가?

### 변수의 이름

이 변수에 대한 도메인 혹은 주제는 무엇인가?

이 변수에 대해 어떤 프로그래밍 개념들이 사용되었는가?

배경을 알지 않으면 의미가 모호한 이름이 있는가?

모호한 변수명이 해당 코드에서 가질 만한 의미는 무엇이 있을까?

서로 관련되어 있는 이름은 무엇인가?

이름으로부터 알 수 있는 사실은 무엇인가?

### 정신모델

표상은 문제에 대해 생각하는 방식에 영향을 미친다.

정신모델은 스코틀랜드 철학자 Kenneth Craik의 1943년 저서 “The Nature of Explanation”에서 처음 소개되었다.

크레이크는 정신 모델을 자연현상에 관한 정신적 “스케일 모델” 이라고 묘사했다.

사람들은 정신 모델을 사용해서 예측하고 추론하고 주변 세계에 대해 설명한다.

풀어야할 문제에 대해 추론하기 위해 사용할 수 있는 작업기억공간 내의 추상화이다.

### 정신모델 자세히 살펴보기

Dedre Gentner, “Psychology of mental models” in International Encylopedia of the Social and Behavioral Sciences, eds. Neil J, Smelser and Paul B. Bates(Elsevier, 2022), 9683-9687

1. 정신모델은 불완전하다.

변수를 값이 들어가있는 박스로 생각하는 것은 재할당에 대해 적절ㄹ하게 설명해주지 못한다.

두번째 값이 첫 번째 값을 가진 박스안에 들어갈 수 있을까? 뺴야하나?

꼭 그렇지만은 않다는 사실을 알 수 있다.

1. 정신 모델은 불완전하지만 확장된다.

처음에는 박스로 비유를 하지만, 시간이 지나면서 변수에는 한 가지 이상의 값을 동시에 저장할 수 없다는 사실을 알게 된다.

1. 모순이 있어도 여러개의 정신 모델이 공존한다.

변수를 박스로 생각할 수도 있고, 이름표로 생각할 수 도 있다.

두 가지 정신 모델은 공존할 수 있는데 각각 다른 상황에서 각자의 장점이 있을 수 있다.

1. 정신 모델은 이상한 것처럼 여겨질 수 있고, 심지어 미신처럼 느껴질 수 도 있다.

컴퓨터를 잘 모른다면, 정신 모델에 따라서 컴퓨터가 사람 말에 반응하는 개체라고 생각할 수도 있다.

1. 사람들은 가급적이면 정신모델을 사용하지 않으려고 한다.

디버깅시, 정신 모델을 만드는데 에너지를 쓰기보다, 코드를 조금만 고친 후 다시 돌려본다.

// `굉장히 의외다. 난 어떻게든 정신모델을 구축하려고 하고 이것만 있으면 모든 문제를 패턴인식으로 해결할 수 있다고 믿고있다.`

### 새로운 정신 모델 배우기

처음 컴퓨터를 접하고 파일시스템을 접했을 때, 파일이 폴더에 들어가있는 것으로 피상적으로 생각한다.

계속 배워가면서, 하드 드라이브 내에서 정보가 저장된 위치에 대한 참조라는 사실을 알게된다.

무언가에 대해 더 깊이 있게 배우고 나면 오래되고 ‘잘못된’ 정신 모델이 두뇌에서 제거되고 더 나은 정신모델로 대체 된다고 생각할 수 있다.

그러나 그러한 정보가 LTM에서 완전히 사라질 가능성은 낮다.

따라서, 이전에 배운 부정확하거나, 불완전한 정신모델을 사용할 위험이 항상 도사리고 있다.

여러 정신 모델이 동시에 활성 상태를 유지할 수 있으며, 모델 간의 경계가 항상 명확한 것은 아니다.

특히 인지 부하가 높은 상황에서는 오래된 모델을 사용할 수 있다.

케네스 크레이크의 정신 모델에 대한 최초의 책 이후 이 주제는 거의 40년 동안 연구되지 않다가 1983년 “Mental Model”이라는 동일한 제목의 두 책이 서로 다른 저자에 의해 각각 출판되었다.

이 두 저자는 뇌에서 정신 모델이 어떻게 처리되는지에 대해 다른 견해를 가지고 있다.

### 작업 기억 공간에서의 정신 모델

프린스턴 대학교 심리학과 교수 Philip Johnson-Larid

1. 국지적 모델을 만든다.

의존 그래프나 상태표를 만들어서 작은 모델들을 만든다.

이는 정신모델의 구성요소로서 사용될 수 있다.

1. 코드에서 관련된 모든 객체와 객체 간의 관계를 나열한다.

국지적 모델에서 만든 구성요소을 이해한 체로, 객체간의 관계가 어떻게 된지 이해할 수 있다.

UML Class Diagram이 도움이 될 것 같다.

전체 시스템을 보다 명확하게 파악할 수 있다.

1. 시스템에 대한 질문을 만들고 이 질문의 답을 사용해서 모델을 개선한다.

1,2단계에서 구성한 정신모델을 작업중인 시스템에 대해 질문과 답변을 하고 코드에서 확인한다.

시스템에서 가장 중요한 요소는 무엇인가? 모델에 그것들이 포함되었는가?

이 중요한 요소들 사이의 관계는 무엇인가?

프로그램의 주요 목표는 무엇인가?

목표가 핵심 요소 및 그 관계와 어떻게 관련되어 있는가?

일반적인 사용 사례는 무엇인가? 모델이 그것을 보여주는가?

### LTM의 정신모델

Bolt Beranek and Newman Inc.의 연구원 Dedre Gentner, Albert Stevens가 썼다.

잠재적 정신 모델의 어휘를 더 많이 쌓아야한다.

코드에 대해서 요약하고, 코드에 대해 이름을 붙이고 확장해야한다.

익숙하지 않은 패턴을 볼 때마다 정신 모델 플래시카드를 추가할 수 있다.

### 개념적 기계(Notional Machine)

컴퓨터가 무엇을 하고 있는지에 대한 추상적 표현으로 두뇌가 생각하는 과정.

1970년대 Logo 언어를 연구하던 서식스 대학교의  Bendu Boulay 교수에 의해 고안.

화학, 물리와 다르게, 정신 모델을 형성했을 때 바로 테스트해 볼 수 있다.

개념적 기계는 코드를 실행하는 실제 기계를 올바르게 이해하기 위해 만들어졌다.

개념적이란?

제시, 추정, 이론에 근거하거나 존재하지만 실제로는 존재하지 않는다는 의미이다.

메모리 주소와 이 주소와 연결하는 변수인 포인터에는 관심을 두지 않는다.

추상적 수준에서 컴퓨터의 동작에 대해 추론하는 것이 필요한 경우에 사용한다.

우리의 두뇌에서 일어나는 것처럼 수학식을 계산하는것 처럼 보이지만, 실제로는 

스택 구조를 사용해서 Polish Notation의 역순으로 변환하여 저장한다.

이것은, 스택 기반 모델보다, 대부분의 프로그래머들의 정신 모델에 더 가깝다.

- 개념적 기계는 의미론인가?

프로그래밍언어에서 개념적 기계가 단순히 의미론을 나타내는 것인지 궁금할지 모르겠다.

그러나 의미론은 수학적 방정식과 수학적 정밀도로 컴퓨터의 동작을 공식화하는 것을 목표로한다.

의미론은 세부사항을 추상화하는 것이 아니라, 세부 사항을 정확하고 완전하게 명시하는 것을 목표로 한다.

즉, 개념적 기계와 의미론은 다르다.
