## 변수 (Variable)

### 변수의 명명 규칙

1. 대소문자가 구분되며 길이에 제한이 없다.
2. 예약어를 사용해서는 안된다.
3. 숫자로 시작해서는 안된다.
4. 특수문자는 ‘_’와

### Java 프로그래머들에게 권장하는 규칙

1. 클래스의 이름의 첫글자는 항상 대문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
    
    ex) LastIndexOf, StringBuffer
    
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 ’_’로 구분한다.
    
    -PI, MAX_NUMBER
    

SnakeCase가 트랜드라고 알고 있었는데, 자바는 CamelCase를 쓰는구나.

특별한 방식으로 식별자를 작성해야한다면 Coding Convention을 미리 정해두고 전체 프로그램에 일관되게 적용하자!

기업마다도 다 다를수 있겠구나.

참고. 자바에서는 모든 이름에 유니코드에 포함된 문자들을 사용할 수 있다.

하지만, 적어도 클래스이름은 ASCII 코드로 하자.

유니코드를 인식하지 못하는 운영체제도 있기 때문이다.

## 변수의 타입

`자바는 C언어와 달리 참조형 변수간의 연산을 할 수 없으므로 실제 연산에 사용되는것은 모두 기본형 변수이다.`

1. 기본형 (Primitive Type)

논리형(Boolean), 문자형(Char), 정수형(Byte, Short, Int, Long), 실수형(Float,double)

8개로 이루어 져있으며, 계산을 위한 `실제값을 저장한다.`

1. 참조형 (Reference Type)

객체의 `주소를 저장한다.`

8개의 기본형을 제외한 나머지 타입.

참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다.

그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.

### 참조변수를 선언하는 방법

```java
클래스이름 변수이름;
Date today = new Date();

/*
객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소이다.
이 주소가 대입연산자'='에 의해서 참조변수 today에 저장되는것이다.
*/
```

변수의 타입이 기본형이 아닌것들은 모두 참조변수이다.

<참고>

참조형 변수는 null또는 객체의 주소 (4byte, 0x0FFFFFFFF)를 값으로 갖는다.

JVM이 32bit가 아니라 64비트라면 변수의 크기는 8byte가 된다.

### Data Type과 Type의 차이

기본형은 저장할 값(Data)의 종류에 따라 구분된다. → ‘Date Type’이라는 용어사용

참조형은 항상 객체의 주소를 저장하므로 값이아닌 객체의 종류이다. → ‘Type’이라는 용어사용

Type이 자료형을 포함하는 보다 넓은 의미이기 때문에, 굳이 구분하지 않아도 된다.

### 기본형 (Primitive Type)

```java
boolean : 다른 기본형과의 연산이 불가능하다. (1byte → `1bit 아니다. 착각하지말자`)

char : 문자를 내부적으로 정수로 저장한다. (2 Byte)
실제로 정수형 또는 실수형과도 연산이 가능하다.

byte : 이진 데이터를 다룰때 사용된다. (1 Byte)

short : C언어와의 호환을 위해서 추가되었다. (2byte)
// 정수형의 기본형인 int보다 짧으므로 short이다.

int : 정수형의 기본자료형이다.
// default라서 리터럴에 따로 추가안해도된다.

long : (8 Byte) 컴파일러에 8byte라는 것을 알려주기위해 L을 붙인다.
//int보다 길다는 의미로 long이다.

float : 실수값을 부동소수점 방식으로 저장하기 때문에 float이라고 명한다. (4 Byte)

double : float보다 두배의 크기(byte)를 갖기 때문에 double이다. (8 Byte)
//실수형의 default는 double이라서 리터럴에 붙이는 d생략이 가능하다.
```

정수형(byte,short,int,long)의 경우 ‘$-2^{n-1} \sim 2^{n-1}-1$(n은 bit수) 라는 정도만 기억하자.

실수형은 정수형과 저장형식이 달라서 같은 크기라도 훨씬 큰값을 표현할 수 있으나 오차가 발생할 수 있다는 단점이 있다.

### long과 double을 자꾸 착각하는 경향이 있다.

long은 정수고, double은 실수다. 확실히 기억하고 넘어가자 !

## 상수와 리터럴(Constant & Literal)

### 상수를 선언하는법

```java
final int MAX_SPPED = 10;

앞에 fianl 만 붙여주면됨.

상수는 반드시 선언과 동시에 초기화해야하며, 그후 부터는 상수의 값을 변경하는것이 허용되지 않는다.

#ERROR Case1
final int MAX_SPEED; -> 상수는 선언과 동시에 초기화 해야함.

#ERROR Case2
final int MAX_VALUE = 100; -> OK 선언과 동시에 초기화됨.
MAX_VALUE = 200; -> ERROR : 상수의 값은 변경할 수 없음.
```

상수의 이름은 모두 대문자로하는것이 암묵적인 관례이고, 여러단어로 이루어져있는 경우 ‘_’로 구분한다.

// 왜 const가 아니라 굳이 final일까..?

JDK1.6부터 상수를 선언과 동시에 초기화하지 않아도된다.

사용하기 전에만 초기화하면 되도록 바뀌었지만

그래도 상수는 선언과 동시에 초기화하는 습관을 들이는게 좋다.

### 리터럴 이란?

프로그래밍에서 상수를 ‘값을 한번 저장하면 변경할 수 없는 저장공간’으로 정의하였기 때문에 이와구분하기 위해 상수를 다른 이름으로 불러야만 했다.

그래서 상수대신 리터럴 이라는 용어를 사용한다.

```java
#Case1

int year = 2014;

year : 변수
2014 : 리터럴

#Case2

final int MAX_VALUE = 100;

MAX_VALUE : 상수
100 : 리터럴
```

### 상수가 필요한 이유

```java
final int WIDTH = 20;
final int HEIGHT = 10;

int triangleArea = (WIDTH * HEGHT) / 2;
int rectangleArea = WIDTH * HEIGHT ;
```

이유1. WIDTH와 HEIGHT만 바꾸면 여러곳을 수정할 필요가 없어지기 때문이다. (재 사용성)

이유2. 가시적인 효과가 있다. WIDTH,HEGHT처럼 리터럴에 의미있는 이름을 붙여주는것이다. (한눈에 의미를 이해)

### 리터럴의 타입과 접미사

변수에 타입이 있는것처럼 리터럴에도 타입이있다.

변수의 타입은 저장될 ‘값의 타입’에 의해 결정되므로, 만일 리터럴에 타입이 없다면 변수의 타입도 필요없을것이다.

정수형의 경우 long타입의 리터럴에 접미사 'l'을 또는 'L'을 붙인다.

(소문자 l은 1과 구분이 잘되지 않으므로 L을 쓰는게 좋다.)

접미사가 없으면 int타입의 리터럴이다.
byte와 short타입의 리터럴은 별도로 존재하지 않는다.

byte와 short타입의 변수에 값을 저장할때는 int타입의 리터럴을 사용한다.

10진수 외에도 2,8,16진수로 표현된 리터럴을 변수에 저장할 수 있으며, 16진수라는 것을 표시하기 위해 리터럴 앞에 접두사'0x' 또는 '0x'를, 8진수의 경우에는 '0'을 붙인다.

```java
int octNum = 010; -> 8진수 10, 10진수로 8
int hexNum = 0x10; -> 16진수 10, 10진수로 16
int binNum = 0b10; -> 2진수 10, 10진수로 2
```

JDK1.7부터 정수형 리터럴의 중간에 구분자’_’를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 되었다.

```java
long big = 100_000_000_000L;
long hex = 0xFFFF_FFFF_FFFF_FFFFL;
```

```java
float pi = 3.14f;
double rate = 1.618d;

//float suffix : ‘f’ or ‘F’
//double suffix : ‘d’ or ‘D’
```

### 타입의 불일치

리터럴의 타입은 저장될 변수의 타입과 일치하는것이 보통이다.

하지만 타입이 달라도 저장 범위가 좁은 타입의 값을 저장하는것은 허용된다.

```java
int i = ‘A’; -> 유니코드 65가 변수 i에 저장
long l = 123; -> int보다 long타입이 범위가 더 넓다.
double d = 3.14f; -> float보다 double타입이 더 범위가 더 넓어서 가능하다.
```

### 문자 리터럴과 문자열 리터럴

문자 리터럴 : ‘A’와 같이 작은 따옴표로 문자하나를 감싼것

문자열 리터럴 : 두 문자 이상이 큰 따옴표로 감싸진것

char : 한 문자를 저장하기 위한 타입

```java

char ch = ‘J’; OK

char ch = ‘’; ERROR -> char는 반드시 하나의 문자가 필요하다.

char ch = ‘ ‘; OK
```

Java는 유니코드에 기반하여 문자를 표현한다.

2byte크기인 자바의 char타입에 하나의 유니코드를 저장한다

String : 여러 문자를 저장하기 위한 타입

```java
String name = “Java”;

String str = “”; 빈 문자열을 허용한다.

// 원래 String은 클래스라서, 객체를 생성하는 연산자 new를 사용해야하지만 특별히 위와 같은 표현도 허용한다.

String name = new String(”Java”);
```

덧셈 연산자를 사용해서 문자열 결합이 가능하다.

```java
String name = “Ja” + “va”;
String str = name + 8.0;

name = "Java"
str = "Java8.0"
```

한쪽은 String이고 다른 한쪽은 다른 Type이 올때, 한쪽을 먼저 String으로 변환한 다음 두 String을 결합한다.

Tip) 숫자를 문자로 변환하고 싶다면 7 + “” 와 같이 작성해주면 된다.

덧셈 연산자는 왼쪽부터 수행하므로 결과가 달라진다는건 생각하고 있어야한다.

ex)

```java
class StringEX{
		public static void main(String[] args){
		System.out.println(7 + 7 + “”); -> return : 14
		System.out.println(”” + 7 + 7); -> return : 77
	}
}
```

### 형식화된 출력 - printf()

처음보는 지시자 ‘%b’ : 불리언 형식으로 출력

println() : 변수를 그대로 내보낼때 사용

printf() : 변수의 형식을 지정해서 내보낼때 사용

```java
System.out.printf("age:%d",age);
System.out.printf("age:%d",14); -> C언어와 같다.
System.out.printf("age:14");

System.out.printf("age:%d%n", age) -> 개행은 \n가 아닌 %n으로 한다.
System.out.printf("hex = %#x %n",hex); -> hex = 0xffffffffffffffff
System.out.printf("c = %c, %d %n", c, (int)c); -> (int(c))로 char를 숫자로 형변환이 가능하다. 

'#'은 0x를 표시해준다.
%#x : 0xffff
%#X : 0xFFF
```

형식 지정자 

```java
%5d : 우측정렬 ,최소 5글자 출력공간 확보 
ex) [   10]

%-5d : 좌측정렬 ,최소 5글자 출력공간 확보
ex) [10   ]

최소이기 때문에 더 늘어나면 그냥 숫자그대로 출력됨.

%05d : 전체를 5공간으로 나누고 숫자를 왼쪽부터 0으로 채움
ex) [00010]

%.5s : 왼쪽에서 5글자만 출력
url = "www.codechobo.com"
ex ) [www.code]

숫자만있으면 우측정렬
0은 0으로 채우기
-는 좌측정렬

.은 소수가 아니라 일부분이다.
밑에나오는 %14.10f와는 다르다. 알고있자.
```

규칙 : %전체자리 칸 수. 소수점아래 자리 칸 수f

```java
double d = 1.23456789;
System.out.printf("%f %n", d);
System.out.printf("%14.10f%n", d); -> %14(전체를 14자리로 설정).10(소수점 아래 10자리)
```

| 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  |  | 1 | . | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 | 0 |

만약 ‘%014.10f’라면 앞에 공백도 0으로 채워질것이다.

%f는 소수점 아래 6자리까지만 출력하고 7자리아래 반올림한다.

// 아래라고 하면 가끔 헷갈릴때가 있었는데, 7자리를 반올림해서 6자리에 올려주는거다.

### 화면에서 입력받기 - Scanner

```java
import java.util.*;

class ScannerEx{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("두자리 정수를 하나 입력해주세요.>");
        String input = scanner.nextLine();
        int num = Integer.parseInt(input);

        System.out.println("입력내용 :"+input);
        System.out.printf("num=%d%n",num);
    }
}
```

지루해 질까봐 미리 소개하는내용이라, 안 배운 부분이 있다고 한다. 그냥 이렇게 쓴다는것만 넘어가자.

## 진법

컴퓨터구조에서 모두 배운 내용이다.

복습겸, 보수법만 조금 적어두자.

어떤 수의 ‘n의 보수’는 더했을 때 n이 되는 수를 말한다.

7의 ‘10의 보수’는 3이고, 3의 ‘10의 보수’는 7이다. 3과 7은 ‘10의 보수관계’에 있다고 한다.

‘2의 보수 관계’ 역시 더해서 2가되는 수의 관계를 말하며 10진수 2는 2진수로 ‘10’이다.

2진수로 ‘10’은 자리올림이 발생하고 0이 되는 수를 뜻한다.

현재 대부분의 시스템은 ‘2의 보수법’으로 부호있는 정수를 표현한다.

## 기본형(Primitive Type)

세부적인 내용을 살펴보자. 다소 깊이 있는 내용이므로 어렵다고 느낄수도 있다.

### 논리형 boolean

1. boolean형 변수의 기본값은 false이다.

1. true와 false 2가지 값만 표현하면 되므로1bit만으로도 충분하지만 

자바에서는 데이터를 다루는 최소단위가 byte기 때문에, boolean의 크기가 1byte이다.

1. 자바에서는 대소문자가 구별되기 때문에 구분해주어야한다.

TRUE, True (X) → true (O)

FALSE, False (X)→ false(O)

### 문자형 char

char ch  =’a’

이 문장은 변수에 ‘문자’가 저장되는것 같지만, 사실은 문자가 아닌 ‘문자의 유니코드(정수)’가 저장된다.

문자’A’의 유니코드는 65이므로, 변수ch에는 65가 저장된다.

그렇기 때문에 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.

즉,

```java
char ch = 'A';
char ch = 65;

다른것이 아니라 동일한것이다.
```

유니코드가 어떤 문자인지 알아내기 위해서는 char형 변수에 저장된 값을 정수형(int)으로 변환하면 된다.

int code = (int)ch;

```java
class VarEx1{
    public static void main(String[] args){
        char ch = 'A';
        int code = (int)ch;

        System.out.printf("%c = %d(%#X) %n", ch , code, code);

        char hch= '가';
        System.out.printf("%c = %d(%#X) %n",hch, (int)hch, (int)hch);
    }
}

return

A = 65(0X41)
가 = 44032(0XAC00)
```

char hch = 0xAC00; 유니코드를 넣을수도 있다.

char hch = ‘\uACC00’;

### 특수문자 다루기

영문자 이외에 tab이나 backspace등의 특수문자를 저장하려면, 조금 특별한 방법을 사용한다.

```java
char tab = '\t';
```

‘t’는 실제로는 두 문자로 이루어져 있지만 한 문자(tab)을 의미한다.

유니코드(16진수)문자 : \u유니코드( ex: char a=’\u0041’ )

### char타입의 표현형식

개수는 2Byte= 16bit 2^16(65536개)이다.

char :

0~2^16-1 (양수만)

short :

2^15~2^15-1 (음수 양수 둘다)

println() :

정수형이면 10진수로 해석하여 출력한다.

문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력한다.

```java
char ch = 'A';
short s = 65;

System.out.println(ch); → A출력(문자형이기 때문)
System.out.println(s); -> 65가 출력된다. (정수형이기 떄문)
```

### 인코딩과 디코딩(encoding & decoding)

문자 인코딩 → A를 65로

문자 디코딩 → 65를 A로

### ASCII 7bit(128개)

1~32번 문자 : 인쇄와 전송 제어용.

33번 이후 : 영대소문자

### Extended ASCII 8bit(255개)

한글 표현에는 부족

한글 표현 방식에는 조합형과 완성형이 존재함.

조합형 : 초성, 중성, 종성을 조합하는 방식

완성형 : 확장 아스키의 일부 영역(162~264)에 해당하는 두 문자코드를 조합하는 방식

현재 조합형은 사용되지 않는다.

현재는 ‘완성형(KSC 5601)’에 없는 잘 안쓰이는 8822개의 글자를 추가한 ‘확장 완성형(CP949)’가 사용한다.

이것이 바로 한글 윈도우에서 사용하는 문자 인코딩이다.

한글 윈도우에서 작성된 문서는 기본적으로 CP949(확장 완성형)’으로 인코딩되어 저장된다.

// 실무에서 CP949를 사용하면 IOS에서 파일을 옮겨 열때 Window의 디코딩 시 문제가 생겨 둘다 호환이 가능한 UTF-8-SIG를 사용헀었다.

### Code Page(CP)

앞서 언급한 CP에 대한 설명

IBM이 자사의 PC에 ‘확장 아스키’를 도입해서 사용하기 시작할 때, PC를 사용하는 지역이나 국가에 따라 여러버전의 ‘확장 아스키’가 필요했다.

IBM은 이들을 ‘Code Page’라 하고, 각 코드페이지에 ‘CP xxx’와 같은 형식으로 이름을 붙였다.

IBM은 MS와 같은 업체들과 협력하여 ‘코드 페이지’를 만들어내고 공유했다.

한글 윈도우는 ‘cp949’, 영문 윈도우는 ‘cp437’을 사용한다.

코드 페이지는 확장 아스키의 256개 문자를 어떤 숫자로 변환할 것인지를 적어노호은 ‘문자 코드표(code page)’일 뿐이다.

### Unicode

2byte (65536개)로 표현하려고 했으나 부족해 21bit( 200만 문자로 확장됨).

이문자들을 표현하기 위해서는 char타입이 아닌 int타입을 사용해야함.

유니코드 인코딩에는 UTF-8, UTF-16, UTF-32등 여러가지 종류가 있는데 자바에서는 UTF-16을 사용한다.

UTF-16 : 모든 문자를 2byte의 고정크기로 표현한다.

UTF-8 : 하나의 문자를 1~4byte의 가변크기로 표현한다.

두 인코딩 모두 처음 128문자가 아스키와 동일하다.

Code Point는 유니코드 문자셋에 순서대로 붙인 일련번호이다.

유니코드에는 발음을 알수 없는 문자들도 많이 포함되어있기때문에, Code Point로 다루는것이 편리하다.

ex) U+0061, U+AC00

모든 문자의 크기가 동일한 UTF-16로 다루면 편리하지만,

간단히 표현할수 있는 대소문자들을 사용할때도 이것을 사용하면 문서의 크기가 커진다는 단점이있다.

인터넷에서는 전송속도가 중요하므로, 문서의 크기가 작을수록 유리하기때문에 UTF-8 인코딩으로 작성된 웹문서의 수가 많다.

### 정수형 - byte, short, int, long

byte (1byte) < short (2byte) < int (4byte) < long (8byte)

2배씩 크기가 증가한다. default 는 int다.

어떤 진법의 리터럴을 변수에 저장해도 `실제로는 2진수로 바뀌어 저장된다.`

2진수가 저장되는 형식은 크게 정수형과 실수형이 있다.

정수형은 다음과 같은 형식으로 저장된다.

S : 부호 비트 (양수는 0, 음수는 1)

n : 타입의 크기 (단위 : bit)

모든 정수형은 부호있는 정수이다. 즉, Sign bit를 가진다.

$2^{n-1} + 2^{n-1} =2^n$개 (2개로 나눠지는 이미지를 기억하는게 중요하다.)

음수는 그대로 $-2^{n-1}$개 양수는 0을 제외하고 $2^{n-1}-1$개가 된다.

-에 1개가 더 많다는것 기억해두자.

byte (-128 ~ 127)

short (-32768~32767)

int (약 +-20억)

long (사실상 엄청나게 커서 대부분 가능)

### 정수형의 선택기준

메모리를 절약하기 위해 byte와 short를 사용할수는 있지만, 

`JVM의 피연산자 스택(operand stack)이 피연산자를 4byte단위로 저장한다.`

그렇기 때문에 크기가 4byte보다 작은자료형의 값을 계산할 때는 4byte로 변환하여 연산이 수행된다.

그래서 오히려 int를 사용하는것이 더 효율적이다.

즉,

1. 정수형 변수를 선언할때는 int타입으로 하자.
2. int의 범위는 20억을 넘을때 long을 사용하자.
3. byte와 short를 사용하는 경우는 성능이 아니라, 공간 절약이 기준이다.

### 정수형의 오버플로우

오버플로우 : 타입이 표현할 수 있는 값의 범위를 넘어서는것

$1111_{(2)} +0001_{(2)} = 10000_{(2)}$

4bit값이라고 한다면 캐리는 버려지고 사실상 0000이된다.

오버플로우가 발생하면 정해진 범위내에서 순환할 뿐이지,

꼭 에러가 발생하는것은 아니다.

다만 예상했던 결과를 얻지 못할 뿐이다.

### 부호있는 정수의 오버플로우

0111 → 7 최대값

1000 → -8 최소값

### 실수형 - float, double

실수형의 범위와 정밀도

float형은 $-1.4 \times 10^{-45} \sim 1.4 \times 10^{-45}$의 범위는 표현할 수 없다.

‘소수는 얼마나 큰 값을 표현할 수 있는가’뿐만 아니라 `‘얼마나 0에 가깝게 표현할 수 있는가’도 중요하다.`

Int : 부호,값

float : 부호,지수,가수

float은 int에 비해 4byte로 큰값을 저장할 수 있지만,

정수형과 달리 실수형은 오차가 발생할 수 있다는 단점이 있다.

그래서 실수형에는 표현할 수 있는 값의 범위뿐만 아니라 ‘정밀도(precision)도 중요하다.

float 타입의 정밀도는 7자리인데, $a\times10^n\ (1 \le a \lt10)$의 형태로 표현된 7자리의 10진수를 오차없이 저장 할 수 있다는 뜻이다.

ex)

$1234.567 = 1.234567 \times 10^3$

$0.00001234567 = 1.234567 \times 10^-5$

$1234567000 = 1.234567 \times 10^9$

만일 7자리 이상의 정밀도가 필요하다면, 변수의 타입을 double로 해야한다.

double타입은 정밀도가 약 2배인, 10진수로 15자리의 정밀도를 가지므로 float타입보다 훨씬 더 정밀하게 값을 표현할 수 있다.

`double이라는 이름은 float보다 약 2배(double)의 정밀도를 갖는다는 의미에서 붙여진것이다.`

실제로 7자리 까지는 잘 저장되는데 이후로는 오차가 생긴다.

9.123456|7891234567890

9.123456|9549560550000

뒷부분은 오차에 의해 다르게 저장된다는점 꼭 알고있자.

`소수점이하 7자리가 아니라, 그냥 7자리다.`

실수형 값을 저장할 때, float타입이 아닌 double타입의 변수를 사용하는 경우는 대부분 저장하려는 ‘값의 범위’ 때문이 아니라 ‘보다 높은 정밀도가’ 필요해서이다.

### 실수형의 저장형식

$\pm M \times 2^E$ 

부동 소수점수는 부호(Sign), 지수(Exponent), 가수(Mantissa)로 나뉜다.

float : 1 + 8 + 23 (32bit)

double : 1 + 11 + 52 = (64bit)

### 지수의 범위

-127~128

하지만 -127과 128은 NaN 또는 양의 무한대, 음의 무한대와 같이 특별한 값의 표현을 위해 에약되어 있으므로 실제로 사용가능한 지수의 범위는 -126~127이다.

그러므로 최대값은 $2^{127}$이고, 10진수로 약 $10^{38}$이다.

Float의 가수는 23이 최대이고 2진수 23자리 = 7자리의 10진수가 되기 때문에, 정밀도는 7이된다.

double은 52이므로 

M은 실제값.

정수형과 달리 ‘2의 보수법’을 사용하지 않기 때문에 그저 부호비트만 0에서 1로 바꾸면 양과 음이 바뀐다.

### 부동소수점의 오차

파이와 같은 무한소수도 존재한다 그렇기에 실수를 저장할때는 오차가 발생할수 있다.

또한 9.1234567과 같은 유한소수가 2진수로 저장되면 무한소수가 된다. 이런 경우도 오차가 발생한다.

2진수로 변환된 실수를 저장할때는 먼저 $1.xxx \times 2^n$의 형태로 변환된다. (정규화)

이때 Float의 가수에 해당하는 23bit만을 받고 뒷부분은 잘려나간다.

잘려나가는 비트가 1이면 반올림되어 반영된다.

잘려나갔을때 발생할수 있는 최대 오차는 약 $2^{-23} = 0.0000001192$이므로, 가수의 마지막 비트단위와 같다.

float의 정밀도가 7자리라고 하는것이다.

지수가 저장될때는 ‘기저법’이라고 해서 2의보수처럼 부호있는 정수를 저장하는 방법이있는데,

지수가 3이면, 최대치인 1 2 4 8 16 32 64 128

저장할 때 특정값(기저)를 더했다가 읽어올때는 다시 빼는 방식이다.

### 실수형에서도 정수형 처럼 저장할 수 있는 범위를 넘게 되면 오버플로우가 발생하는가?

정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은 ‘무한대(infinity)’가 된다.

그리고 정수형에는 없는 ‘언더플로우(underflow)’가 있는데, 실수형으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되는 경우. `이때 변수의 값은 0이된다.`

## 형변환

형변환(캐스팅, casting)이란?

서로 다른 타입간의 연산을 수행하기 위해, 타입을 일치시키는 과정.

변수나 리터럴의 타입을 다른 타입으로 변환하는것이다.

### 정수형간의 형변환

int타입의 값을 byte타입으로 변화시키는 경우, 비트의 오른쪽부터 8bit씩만 남는다.

byte에서 int로 옮길때는 당연히 손실이 없고 추가된 비트는 모두 0으로 채워진다.

변환하려는 값이 음수인 경우에는 빈공간을 1로 채운다.

형변환 후에도 부호를 유지할 수 있도록 하기 위해서이다.

### 실수형 간의 형변환

float타입의 값을 double로 변환하는 경우,

지수 float의 기저인 127을 빼고 double의 기저인 1023을 더해서 변환한다. (그냥 넘어가자)

가수는 float의 가수 23자리를 채우고 남은 자리를 0으로 채운다.

double타입에서 float타입으로 변환하는 경우,

지수는 double의 기저인 1023을 뺀 후 float의 기저인 127을 더해서 변환한다.

가수는 double의 가수 52자리 중 23자리만 저장되고 나머지는 버려진다.

이때 가수 24번째 자리에 만약에 1이 있다면, 반올림되어 23자리에 반영된다.

### 정수형과 실수형 간의 형변환

### 정수형을 실수형으로 변환

`핵심은 정밀도이다.`

몇 자리까지 사용할 것인가?

7자리인가? 그럼 float써도된다.

10진수로 8자리 이상의 값을 실수형으로 변환할때는 double형을 써야한다.

8자리 부터는 오차가 발생하기 때문이다.

### 실수형을 정수형으로 변환

이진수로 나열했을때, 

9.1234567f는 1001.xxxxxx 보이는 1001을 제외한 나머지는 버려진다.

만일 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘을때는 정수의 오버플로우가 발생한 결과를 얻는다.

### 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는것이 원칙이다.

하지만 형변환을 생략할 수 도 있다.

이때,`컴파일러가 생략된 형변환을 자동적으로 추가한다.`

```java
float f = 1234;

float f = (float)1234;
```

생략해도 문제가 없다.

하지만 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생한다.

ex) byte b = 1000; (원래 가능한 범위는 -127~128)

서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행한다.

### 자동 형변환의 규칙

기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.

char와 short는 둘다 2byte의 크기로 크기가 같다 하지만, 서로 범위가 달라서 둘중 어느쪽으로의 형변환도 값손실이 발생할 수 있으므로 자동형변환이 수행될 수 없다.
