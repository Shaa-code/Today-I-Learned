### 스프링 트랜잭션 전파1 - 기본

트랜잭션이 둘 이상 있을 때 어떻게 동작하는지 자세히 알아보고, 스프링이 제공하는 트랜잭션 전파(propagation)이라는 개념도 알아보자.

트랜잭션 전파를 이해하는 과정을 통해서 스프링 트랜잭션의 동작 원리도 더 깊이있게 이해할 수 있을 것이다.

먼저 간단한 스프링 트랜잭션 코드를 통해 기본 원리를 학습하고, 이후에 실제 예제를 통해 어떻게 활용하는지 알아보겠다.

간단한 예제 코드로 스프링 트랜잭션을 실행해보자.

- BasicTxTest

```java
@Slf4j
@SpringBootTest
public class BasicTxTest {

    @Autowired
    PlatformTransactionManager txManager;

    @TestConfiguration
    static class Config{
        @Bean
        public PlatformTransactionManager transactionManager(DataSource dataSource){
            return new DataSourceTransactionManager(dataSource);
        }

    }

    @Test
    void commit(){
        log.info("트랜잭션 시작");
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());

        log.info("트랜잭션 커밋");
        txManager.commit(status);
        log.info("트랜잭션 커밋 완료");
    }

    @Test
    void rollback(){
        log.info("트랜잭션 시작");
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());

        log.info("트랜잭션 롤백 시작");
        txManager.rollback(status);
        log.info("트랜잭션 롤백 완료");
    }
}
```

잘 작동하고 기본이다.

### 스프링 트랜잭션 전파2 - 트랜잭션 두 번 사용

이번에는 트랜잭션이 각각 따로 사용되는 경우를 확인해 보자.

이 예제는 트랜잭션1이 완전히 끝나고나서 트랜잭션2를 수행한다.

```java
2023-07-26 16:30:36.120  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : Started BasicTxTest in 4.052 seconds (JVM running for 5.844)
2023-07-26 16:30:36.244  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션 1 시작
2023-07-26 16:30:36.248 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2023-07-26 16:30:36.248 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1375340999 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA] for JDBC transaction
2023-07-26 16:30:36.251 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1375340999 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA] to manual commit
2023-07-26 16:30:36.252  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션 1 커밋 시작
2023-07-26 16:30:36.252 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2023-07-26 16:30:36.252 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@1375340999 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA]
2023-07-26 16:30:36.253 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1375340999 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA] after transaction
2023-07-26 16:30:36.253  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션 1 커밋 완료
2023-07-26 16:30:36.253  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션 2 시작
2023-07-26 16:30:36.253 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2023-07-26 16:30:36.253 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@681419196 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA] for JDBC transaction
2023-07-26 16:30:36.254 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@681419196 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA] to manual commit
2023-07-26 16:30:36.254  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션 2 커밋
2023-07-26 16:30:36.254 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2023-07-26 16:30:36.254 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@681419196 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA]
2023-07-26 16:30:36.254 DEBUG 16192 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@681419196 wrapping conn0: url=jdbc:h2:mem:84129c78-2afc-433f-b373-54b34ab02c6d user=SA] after transaction
2023-07-26 16:30:36.254  INFO 16192 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션 2커밋 완료
2023-07-26 16:30:36.291  INFO 16192 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
```

- 트랜잭션1

트랜잭션1은 시작이후에, 커넥션 풀에서 conn0 커넥션을 획득한다.

트랜잭션1을 커밋한 후에, 커넥션 풀에 conn0 커넥션을 반납한다.

- 트랜잭션2

트랜잭션2를 시작하고, 커넥션 풀에서 conn0을 획득한다.

트랜잭션2를 커밋하고, 커넥션 풀에 conn0을 반납한다.

로그를 보면 트랜잭션 1과 트랜잭션 2가 같은 conn0을 사용중이다.

이것은 중간에 커넥션 풀 때문에 그런 것이다.

트랜잭션1은 conn0 커넥션을 모두 사용하고 커넥션 풀에 반납까지 완료했다.

이후에 트랜잭션2가 conn0을 커넥션 풀에서 획득한 것이다.

물리적으로는 같은 커넥션이 맞다.

하지만 같은 커넥션 풀이 아니라고 생각한다면 둘은 완전히 다른 커넥션으로 인지하는 것이 맞다.

그렇다면 둘을 구분할 수 있는 다른 방법은 없을까?

- 주의

히카리 커넥션 풀에서 커넥션을 획득하면 실제 커넥션을 그대로 반납하는 것이 아니라

내부 관리를 위해 히카리 프록시 커넥션이라는 객체를 생성해서 반환한다.

물론 내부에는 실제 커넥션이 포함되어 있다.

이 객체의 주소를 확인하면 커넥션 풀에서 획득한 커넥션을 구분할 수 있다.

트랜잭션1 : Acquired Connection [HikariProxyConnection@1000000 wrapping conn0]

트랜잭션2 : Acquired Connection [HikariProxyConnection@2000000 wrapping conn0]

히카리 커넥션풀이 반환해주는 커넥션을 다루는 프록시 객체의 주소가

트랜잭션1은 HikariProxyConnection@1000000 이고,

트랜잭션2는 HikariProxyConnection@2000000 으로

서로 다른것을 확인할 수 있다.

결과적으로 conn0을 통해 물리적으로는 같은 커넥션이 재사용된 것을 확인할 수 있고,

HikariProxyConnection@1000000, HikariProxyConnection@2000000을 통해

각각 커넥션 풀에서 커넥션을 조회한 것을 확인할 수 있다.

// 결국 하고 싶은말은 반납을 하고 새로 조회를 한것이라는 사실이다.

// 여기서 HikariProxyConnection은 호출 시 계속해서 새로 생성된다는 사실을 알아야한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec0d6241-bac6-4fee-98b4-0ba3dc220882/Untitled.png)

대충 생각하면 위의 그림이다.

커넥션 풀을 사용하지 않는다고 가정할 때의 그림이다.

더 자세히 보려면 아래 그림을 보자.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23f9ced5-6881-4c2a-8ae0-a959ad226617/Untitled.png)

1. 클라이언트가 로직1을 호출한다.
2. 트랜잭션이 실행되면서 con1을 얻고 setAutoCommitFalse()를 설정한 후 로직1을 돌린다.
3. 트랜잭션1이 커밋을 요청하고 커밋을 한다.
4. 이후 conn1을 반환한다.

2번째도 반복한다.

트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다르다.

이 경우 트랜잭션을 각자 관리하기 때문에 전체 트랜잭션을 묶을 수 없다.

예를 들어서 트랜잭션1이 커밋하고, 트랜잭션2가 롤백하는 경우 트랜잭션1에서 저장한 데이터는 커밋되고, 트랜잭션2에서 저장한 데이터는 롤백된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0438fdd3-22a8-4289-a69a-03b8b5dac103/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46f00737-7f9a-46ce-af43-ace12eb5f27c/Untitled.png)

// 여기서 영한님이 알려주고 싶었던 내용은 트랜잭션이 각각 따로 동작한다는 사실을 보여주고 싶었던 것이다.

여기까지는 이미 앞서 학습한 내용들이라 이해하기 어렵지 않을 것이다.

이제 본격적으로 트랜잭션 전파에 대해서 알아보자.

### 스프링 트랜잭션 전파3 - 전파 기본

트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 여기에 추가로 트랜잭션을 수행하면 어떻게 될까?

기존 트랜잭션과 별도의 트랜잭션을 진행해야 할까? 아니면 기존 트랜잭션을 그대로 이어 받아서 트랜잭션을 수행해야 할까?

이런 경우 `어떻게 동작할지 결정하는 것을 트랜잭션 전파(propagation)이라 한다.`

참고로 스프링은 다양한 트랜잭션 전파 옵션을 제공한다.

- 참고

지금부터 설명하는 내용은 트랜잭션 전파의 기본 옵션인 REQUIRED를 기준으로 설명한다ㅏ.

옵션에 대한 내용은 마지막에 설명한다. 뒤에서 설명할 것이므로 참고만 해두자.

예제를 통해 본격적으로 스프링이 제공하는 트랜잭션 전파에 대해서 알아보자.

- 외부 트랜잭션이 수행중인데, 내부 트랜잭션이 추가로 수행됨

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3e939207-871b-4337-89c1-0f323bb4c0c0/Untitled.png)

외부 트랜잭션이 수행중이고, 아직 끝나지 않았는데, 내부 트랜잭션이 수행된다.

외부 트랜잭션이라고 이름 붙인 것은 둘 중 상대적으로 밖에 있기 때문에 외부 트랜잭션이라 한다.

처음 시작된 트랜잭션으로 이해하면 된다.

내부 트랜잭션은 외부에 트랜잭션이 수행되고 있는 도중에 호출되기 때문에 마치 내부에 있는 것 처럼 보여서 내부 트랜잭션이라 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d961ba8a-8327-4c1b-9a10-b779228403d6/Untitled.png)

스프링은 이 경우 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어 준다.

// 이게 기본 전파 방식이다.

내부 트랜잭션이 외부 트랜잭션에 참여하는 것이다.

이것이 기본 동작이고, 옵션을 통해 다른 동작방식도 선택할 수 있다.

(다른 동작 방식은 뒤에 설명한다.)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43fc3e9b-61f1-4ec6-81ec-39f47880e7e1/Untitled.png)

스프링은 이해를 돕기 위해 논리 트랜잭션과 물리 트랜잭션이라는 개념을 나눈다.

논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶인다.

`물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다.`

실제 커넥션을 통해서 트랜잭션을 시작(setAutoCommit(false))하고,

실제 커넥션을 통해서 커밋, 롤백하는 단위이다.

`논리 트랜잭션은 트랜잭션 매니저를 통해서 트랜잭션을 사용하는 단위이다.`

이러한 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타난다.

단순히 트랜잭션이 하나인 경우 둘을 구분하지는 않는다.

더 정확히는 REQUIRED 전파 옵션을 사용하는 경우에 나타나고, 이 옵션은 뒤에서 설명한다.

- 그럼 왜 이렇게 논리 트랜잭션과 물리 트랜잭션을 나누어 설명하는 것일까?

트랜잭션이 사용중일 때 또 다른 트랜잭션이 내부에 사용되면 여러가지 복잡한 상황이 발생한다.

// 첫번째 로직을 수행완료하고,  두번째 로직을 수행하고 있는데 롤백을 해야하면 어디까지 롤백해야하지? 와 같은 문제이다.

이때 논리 트랜잭션 개념을 도입하면 다음과 같은 단순한 원칙을 만들 수 있다.

- 원칙

모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.

하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.

풀어서 설명하면 이렇게 된다.

모든 트랜잭션 매니저를 커밋해야 물리 트랜잭션이 커밋된다.

하나의 트랜잭션 매니저라도 롤백하면 물리 트랜잭션은 롤백된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/38861a1e-d259-42f1-bbf4-eaae7934f938/Untitled.png)

모든 논리 트랜잭션이 커밋 되었으므로 물리 트랜잭션도 커밋된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68ef6625-846c-4602-b680-71176fcba961/Untitled.png)

외부 논리 트랜잭션이 롤백 되었으므로 물리 트랜잭션은 롤백된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae520b9c-aa93-486a-ba7e-b08e2710e73e/Untitled.png)

내부 논리 트랜잭션이 롤백 되었으므로 물리 트랜잭션은 롤백 된다.

### 스프링 트랜잭션 전파4 - 전파 예제

더 자세히 알아보자

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/38861a1e-d259-42f1-bbf4-eaae7934f938/Untitled.png)

```java
@Test
void inner_commit(){
    log.info("외부 트랜잭션 시작");
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("outer.isNewTransaction() = {}", outer.isNewTransaction());

    log.info("내부 트랜잭션 시작");
    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("inner.isNewTransaction = {}", inner.isNewTransaction());
    log.info("내부 트랜잭션 커밋");
    txManager.commit(inner);

    log.info("외부 트랜잭션 커밋");
    txManager.commit(outer);
}
```

외부 트랜잭션이 수행중인데, 내부 트랜잭션을 추가로 수행했다.

외부 트랜잭션은 처음 수행된 트랜잭션이다.

이 경우 신규 트랜잭션(isNewTransaction=true)가 된다.

내부 트랜잭션을 시작하는 시점에는 이미 외부 트랜잭션이 진행중인 상태이다.

이 경우 내부 트랜잭션은 외부 트랜잭션에 참여한다.

- 트랜잭션 참여

내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다는 뜻이다.

다른 관점으로 보면 외부 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻이다.

외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻이다.

정리하면 외부 트랜잭션과 내부 트랜잭셔이 하나의 물리 트랜잭션으로 묶이는 것이다.

`내부 트랜잭션은 이미 진행중인 외부 트랜잭션에 참여한다.`

이 경우 신규 트랜잭션이 아니다.

예제에서는 둘 다 성공적으로 커밋한다.

위의 예제에서 외부 트랜잭션과 내부 트랜잭션이 하나의 물리 트랜잭션으로 묶인다고 설명했다.

그런데 코드를 잘 보면 커밋을 두 번 호출했다.

트랜잭션을 생각해보면 하나의 커넥션에 커밋은 한번만 호출할 수 있다.

커밋이나 롤백을 하면 해당 트랜잭션은 끝나버린다.

```java
txManager.commit(inner);
txManager.commit(outer);
```

스프링은 어떻게 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 물리 트랜잭션으로 동작하게 하는지 자세히 알아보자.

- 실행결과 - inner_commit()

```java
2023-07-26 18:18:10.538  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : Started BasicTxTest in 3.646 seconds (JVM running for 5.466)
2023-07-26 18:18:10.702  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 시작
2023-07-26 18:18:10.704 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2023-07-26 18:18:10.704 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1151632828 wrapping conn0: url=jdbc:h2:mem:6e1add76-2356-4f26-a6ae-0f3406752ac3 user=SA] for JDBC transaction
2023-07-26 18:18:10.707 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1151632828 wrapping conn0: url=jdbc:h2:mem:6e1add76-2356-4f26-a6ae-0f3406752ac3 user=SA] to manual commit
2023-07-26 18:18:10.707  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : outer.isNewTransaction() = true
2023-07-26 18:18:10.707  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 시작
2023-07-26 18:18:10.708 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Participating in existing transaction
2023-07-26 18:18:10.708  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : inner.isNewTransaction = false
2023-07-26 18:18:10.708  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 커밋
2023-07-26 18:18:10.708  INFO 3552 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 커밋
2023-07-26 18:18:10.708 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2023-07-26 18:18:10.708 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@1151632828 wrapping conn0: url=jdbc:h2:mem:6e1add76-2356-4f26-a6ae-0f3406752ac3 user=SA]
2023-07-26 18:18:10.709 DEBUG 3552 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1151632828 wrapping conn0: url=jdbc:h2:mem:6e1add76-2356-4f26-a6ae-0f3406752ac3 user=SA] after transaction
2023-07-26 18:18:10.732  INFO 3552 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default
```

내부 트랜잭션을 시작할 때 Participating in exsting transaction 이라는 메시지를 확인할 수 있다.

이 메시지는 내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다는 뜻이다.

실행 결과를 보면 외부 트랜잭션을 시작하거나 커밋할 때는 DB 커넥션을 통한 물리 트랜잭션을 시작(manual commit)하고

DB 커넥션을 통해 커밋하는 것을 확인할 수 있다.

그런데 내부 트랜잭션을 시작하거나 커밋할 때는 DB 커넥션을 통해 커밋하는 로그를 전혀 확인할 수 없다.

// 실제로 Initiating transaction commit과 같은 로그가 보이지 않는다.

내부 트랜잭션에서 그냥 commit이 호출되면 그냥 무시하고 넘어간다.

정리하면 외부 트랜잭션만 물리 트랜잭션을 시작하고, 커밋한다.

만약 내부 트랜잭션이 실제 물리 트랜잭션을 커밋하면 트랜잭션이 끝나버리기 때문에, 트랜잭션을 처음 시작한 외부 트랜잭션까지 이어갈 수 없다.

따라서 내부 트랜잭션은 DB 커넥션을 통한 물리 트랜잭션을 커밋하면 안된다.

스프링은 이렇게 여러 트랜잭션이 함께 사용되는 경우, 처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리하도록 한다.

이를 통해 트랜잭션 중복 커밋 문제를 해결한다.

트랜잭션 전파가 실제 어떻게 동작하는지 그림으로 알아보자.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2adab5a4-40ba-43bb-8cbe-a3eb08d3bc3c/Untitled.png)

- 요청 흐름 - 외부 트랜잭션
1. txManager.getTransaction()을 호출해서 외부 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.
3. 생성한 커넥션을 수동 커밋 모드 setAutoCommit(false)로 설정한다. [물리 트랜잭션 시작]
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨있다.

```java
if (isExistingTransaction(transaction)) {
   // Existing transaction found -> check propagation behavior to find out how to behave.
   return handleExistingTransaction(def, transaction, debugEnabled);
}

@Override
protected boolean isExistingTransaction(Object transaction) {
	DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
	return (txObject.hasConnectionHolder() && txObject.getConnectionHolder().isTransactionActive());
}
```

isNewTransaction()을 통해 신규 트랜잭션 여부를 확인할 수 있다. 트랜잭션을 처음 시작했으므로 신규 트랜잭션이다.

1. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다.

- 요청 흐름 - 내부 트랜잭션
1. txManager.getTransaction()를 호출해서 내부 트랜잭션을 호출한다.
2. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다.
3. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여한다.

`기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻이다.` (완전 아무것도 안하는건 아니다. 위와 같은 코드를 수행한다.)

이미 기존 트랜잯션인 외부 트랜잭션에서 물리 트랜잭션을 시작했다.

그리고 물리 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 담아두었다.

따라서 이미 물리 트랜잭션이 진행중이므로 그냥 두면 이후 로직이 기존에 시작된 트랜잭션을 자연스럽게 사용하게 되는 것이다.

이후 로직은 자연스럽게 트랜잭션 동기화 매너지에 담아두었다.

1. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus에 담아서 반환하는데, 여기에서 isNewTransaction을 통해 신규 트랜잭션 여부를 확인할 수 있다.

여기서 기존 트랜잭션에 참여했기 때문에 신규 트랜잭션이 아니다. (false)

1. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92e5cf22-9c84-4318-b6bd-c11f0f937ff3/Untitled.png)

- 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.
2. `트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.`

`이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다.`

이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.

아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다.

물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다. (// 물리 트랜잭션이라기보다, 첫번째(신규) 트랜잭션(isNewTransaction())으로 보는게 적절할 듯 하다.)

- 응답 흐름 - 외부 트랜잭션
1. 로직 1이 끝나고 트랜잭션 매니저를 통배 외부 트랜잭션을 커밋한다.
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.

외부 트랜잭션은 신규 트랜잭션이다.

따라서 DB 커넥션에 실제 커밋을 호출한다.

1. 트랜잭션 매니저에 커밋하는 것이 논리적인 커밋이라면, 실제 커넥션에 커밋하는 것을 물리 커밋이라 할 수 있다.

실제 데이터베이스에 커밋이 반영되고, 물리 트랜잭션도 끝난다.

- 핵심 정리

여기서 핵심은 트랜잭션 매니저에 커밋을 호출한다고해서 항상 실제 커넥션에 물리 커밋이 발생하지는 않는다는 점이다.

신규 트랜잭션인 경우에만 실제 커넥션을 사용해서 물리 커밋과 롤백을 수행한다.

신규 트랜잭션이 아니면 실제 물리 커넥션을 사용하지 않는다.

이렇게 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저에 커밋하는 것이 항상 물리 커밋으로 이어지지 않는다.

그래서 이 경우 논리 트랜잭션과 물리 트랜잭션을 나누게 된다.

또는 외부 트랜잭션과 내부 트랜잭션으로 나누어 설명하기도 한다.

트랜잭션이 내부에서 추가로 사용되면, 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고,

모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋된다고 이해하면 된다.

### 스프링 트랜잭션 전파5 - 외부 롤백

이번에는 내부 트랜잭션은 커밋되는데, 외부 트랜잭션이 롤백되는 상황을 알아보자.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45bea60e-c50a-4691-8dcd-af4ae949a8c2/Untitled.png)

`논리 트랜잭션이 하나라도 롤백되면 전체 물리 트랜잭션은 롤백된다.`

따라서 이 경우 내부 트랜잭션이 커밋했어도, 내부 트랜잭션 안에서 저장한 데이터도 모두 함께 롤백된다.

```java
@Test
void outer_rollback(){
    log.info("외부 트랜잭션 시작");
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("outer.isNewTransaction() = {}", outer.isNewTransaction());

    log.info("내부 트랜잭션 시작");
    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("inner.isNewTransaction = {}", inner.isNewTransaction());
    log.info("내부 트랜잭션 커밋");
    txManager.commit(inner);

    log.info("외부 트랜잭션 롤백");
    txManager.rollback(outer);
}
```

```java
2023-07-26 22:43:40.462  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : Started BasicTxTest in 4.43 seconds (JVM running for 6.503)
2023-07-26 22:43:40.629  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 시작
2023-07-26 22:43:40.632 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2023-07-26 22:43:40.633 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1461249916 wrapping conn0: url=jdbc:h2:mem:5b9dc6a9-095d-4fda-b1d0-3dc71f286845 user=SA] for JDBC transaction
2023-07-26 22:43:40.636 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1461249916 wrapping conn0: url=jdbc:h2:mem:5b9dc6a9-095d-4fda-b1d0-3dc71f286845 user=SA] to manual commit
2023-07-26 22:43:40.637  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : outer.isNewTransaction() = true
2023-07-26 22:43:40.637  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 시작
2023-07-26 22:43:40.637 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Participating in existing transaction
2023-07-26 22:43:40.637  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : inner.isNewTransaction = false
2023-07-26 22:43:40.637  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 커밋
2023-07-26 22:43:40.637  INFO 30388 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 롤백
2023-07-26 22:43:40.637 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction rollback
2023-07-26 22:43:40.637 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Rolling back JDBC transaction on Connection [HikariProxyConnection@1461249916 wrapping conn0: url=jdbc:h2:mem:5b9dc6a9-095d-4fda-b1d0-3dc71f286845 user=SA]
2023-07-26 22:43:40.638 DEBUG 30388 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1461249916 wrapping conn0: url=jdbc:h2:mem:5b9dc6a9-095d-4fda-b1d0-3dc71f286845 user=SA] after transaction
2023-07-26 22:43:40.666  INFO 30388 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
```

외부 트랜잭션이 물리 트랜잭션을 시작하고 롤백하는 것을 확인할 수 있다.

내부 트랜잭션은 앞서 배운대로 직접 물리 트랜잭션에 관여하지 않는다.

결과적으로 외부 트랜잭션에서 시작한 물리 트랜잭션의 범위가 내부 트랜잭션까지 사용된다.

이후 외부 트랜잭션이 롤백되면서 전체 내용은 모두 롤백된다.

- 응답 흐름

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/304222d2-5e33-46cd-92b7-d6a992a6f93f/Untitled.png)

요청 흐름은 앞서 본 것과 같으므로 생략했다.

이번에는 응답 흐름에 집중해보자.

- 응답 흐름 - 내부 트랜잭션
1. 로직 2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다.

이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.

아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다. 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 한다.

- 응답 흐름 - 외부 트랜잭션
1. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백한다.
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.

외부 트랜잭션은 신규 트랜잭션이다.

1. 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있다.

실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.

앞서 학습한 내용과 거의 같고, 커밋을 롤백으로 바꾸었을 뿐이기 때문에 이해가 어렵지는 않을 것이다. 

### 스프링 트랜잭션 전파6 - 내부 롤백

이번에는 내부 트랜잭션은 롤백되는데, 외부 트랜잭션이 커밋되는 상황을 알아보자.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6939149c-d738-467f-907e-d8a109e218cf/Untitled.png)

이 상황은 겉으로 보기에는 단순하지만, 실제로는 단순하지 않다.

내부 트랜잭션이 롤백을 했지만, 내부 트랜잭션은 물리 트랜잭션에 영향을 주지 않는다.

그런데 외부 트랜잭션은 커밋을 해버린다.

지금까지 학습한 내용을 돌아보면 외부 트랜잭션만 물리 트랜잭션에 영향을 주기 때문에 물리 트랜잭션이 커밋될 것 같다.

전체를 롤백해야 하는데, 스프링은 이 문제를 어떻게 해결해야 할까?

```java
@Test
void inner_rollback(){
    log.info("외부 트랜잭션 시작");
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("outer.isNewTransaction() = {}", outer.isNewTransaction());

    log.info("내부 트랜잭션 시작");
    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("inner.isNewTransaction = {}", inner.isNewTransaction());
    log.info("내부 트랜잭션 롤백");
    txManager.rollback(inner);

    log.info("외부 트랜잭션 커밋");
    txManager.commit(outer);
}
```

```java
2023-07-26 23:08:16.194  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : Started BasicTxTest in 4.021 seconds (JVM running for 6.064)
2023-07-26 23:08:16.344  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 시작
2023-07-26 23:08:16.346 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2023-07-26 23:08:16.347 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@680034596 wrapping conn0: url=jdbc:h2:mem:336b621e-3572-4bfa-bfa1-d36fe9866228 user=SA] for JDBC transaction
2023-07-26 23:08:16.349 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@680034596 wrapping conn0: url=jdbc:h2:mem:336b621e-3572-4bfa-bfa1-d36fe9866228 user=SA] to manual commit
2023-07-26 23:08:16.349  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : outer.isNewTransaction() = true
2023-07-26 23:08:16.350  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 시작
2023-07-26 23:08:16.351 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Participating in existing transaction
2023-07-26 23:08:16.351  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : inner.isNewTransaction = false
2023-07-26 23:08:16.351  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 롤백
2023-07-26 23:08:16.351 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Participating transaction failed - marking existing transaction as rollback-only
2023-07-26 23:08:16.351 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Setting JDBC transaction [HikariProxyConnection@680034596 wrapping conn0: url=jdbc:h2:mem:336b621e-3572-4bfa-bfa1-d36fe9866228 user=SA] rollback-only
2023-07-26 23:08:16.351  INFO 8312 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 커밋
2023-07-26 23:08:16.351 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Global transaction is marked as rollback-only but transactional code requested commit
2023-07-26 23:08:16.352 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction rollback
2023-07-26 23:08:16.352 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Rolling back JDBC transaction on Connection [HikariProxyConnection@680034596 wrapping conn0: url=jdbc:h2:mem:336b621e-3572-4bfa-bfa1-d36fe9866228 user=SA]
2023-07-26 23:08:16.352 DEBUG 8312 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@680034596 wrapping conn0: url=jdbc:h2:mem:336b621e-3572-4bfa-bfa1-d36fe9866228 user=SA] after transaction
```

`// 실무에서 만나는 문제이고 굉장히 중요한 문제인데, 해결하기 어려워 한다고 한다.`

- 외부 트랜잭션 시작

물리 트랜잭션을 시작한다.

- 내부 트랜잭션 시작

Participating in existing transaction

기존 트랜잭션에 참여한다.

- 내부 트랜잭션 롤백

Participating transaction failed - marking existing transaction as rollback-only

내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지 않는다.

`대신에 기존 트랜잭션을 롤백 전용으로 표시한다.`

- 외부 트랜잭션 커밋

외부 트랜잭션을 커밋한다.

Global transaction is marked as rollback-only

`커밋을 호출했지만, 전체 트랜잭션이 롤백 전용으로 표시되어 있다.`

따라서 물리 트랜잭션을 롤백한다.

// 내 생각에 구현이 굉장히 쉽다고 느껴졌다.

// 그냥 내부 롤백이 실행되면 내부 롤백이 실행되었다는 flag에 true를 만들고

// 외부 커밋을 실행하기 직전에 트랜잭션에 이어지는 flag들을 점검하면 끝이라고 생각했다.

// 실제로도 그렇게 구현하고 있다는걸 발견했다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77431f6a-74cf-4217-bbc3-4c58778f5114/Untitled.png)

- 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다. (로직2에 문제가 있어서 롤백한다고 가정한다.)
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않는다.

이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.

아직 트랜잭션이 끝난 것이 아니기 때문에 실제 롤백을 호출하면 안된다.

물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 한다.

1. 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 rollbackOnly=true라는 표시를 해둔다.

```java
@Override
protected void doSetRollbackOnly(DefaultTransactionStatus status) {
   DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
   if (status.isDebug()) {
      logger.debug("Setting JDBC transaction [" + txObject.getConnectionHolder().getConnection() +
            "] rollback-only");
   }
   txObject.setRollbackOnly();
}

/**
* Mark the resource transaction as rollback-only.
*/

public abstract class ResourceHolderSupport implements ResourceHolder {

private boolean rollbackOnly = false;

public void setRollbackOnly() {
    this.rollbackOnly = true;
}

//ConnectionHolder는 ResourceHodlerSupport를 상속(extends)받아 사용한다.
```

- 실제 롤백 프로세스 로직

```java
private void processRollback(DefaultTransactionStatus status, boolean unexpected) {
   try {
      boolean unexpectedRollback = unexpected;

      try {
         triggerBeforeCompletion(status);

         if (status.hasSavepoint()) {
            if (status.isDebug()) {
               logger.debug("Rolling back transaction to savepoint");
            }
            status.rollbackToHeldSavepoint();
         }
         else if (status.isNewTransaction()) {
            if (status.isDebug()) {
               logger.debug("Initiating transaction rollback");
            }
            doRollback(status);
         }
         else {
            // Participating in larger transaction
            if (status.hasTransaction()) {
               if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
                  if (status.isDebug()) {
                     logger.debug("Participating transaction failed - marking existing transaction as rollback-only");
                  }
                  doSetRollbackOnly(status);
               }
               else {
                  if (status.isDebug()) {
                     logger.debug("Participating transaction failed - letting transaction originator decide on rollback");
                  }
               }
            }
            else {
               logger.debug("Should roll back transaction but cannot - no transaction available");
            }
            // Unexpected rollback only matters here if we're asked to fail early
            if (!isFailEarlyOnGlobalRollbackOnly()) {
               unexpectedRollback = false;
            }
         }
      }
      catch (RuntimeException | Error ex) {
         triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
         throw ex;
      }

      triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);

      // Raise UnexpectedRollbackException if we had a global rollback-only marker
      if (unexpectedRollback) {
         throw new UnexpectedRollbackException(
               "Transaction rolled back because it has been marked as rollback-only");
      }
   }
   finally {
      cleanupAfterCompletion(status);
   }
}
```

`여기서 배운점이 코드를 크게 분기문으로 나눌 때는, else문 뒤에 어떤 상황에 분기가 되는지 주석을 꼭 달아준다.`

혹시 모를 상황들에 대해서도 if문을 작성할 때 주석을 달아주는걸 볼 수 있다.

- 응답 흐름 - 외부 트랜잭션
1. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다.
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.

외부 트랜잭션은 신규 트랜잭션이다.

따라서 DB 커넥션에 실제 커밋을 호출해야 한다.

이때 먼저 트랜잭션 동기화 매니저에 롤백 전용(rollbackOnly = true) 표시가 있는지 확인한다.

롤백 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백한다.

1. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.
2. 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 분명 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 되어버렸다.

이것은 조용히 넘어갈 수 있는 문제가 아니다.

`시스템 입장에서는 커밋을 호출했지만 롤백이 되었다는 것은 분명하게 알려주어야 한다.`

`예를 들어서 고객은 주문이 성공했다고 생각했는데, 실제로는 롤백이 되어서 주문이 생성되지 않은 것이다.`

`스프링은 이 경우 UnexpectedRollbackException 런타임 예외를 던진다.`

그래서 커밋을 시도했지만, 기대하지 않은 롤백이 되어서 주문이 생성되지 않은 것이다.

스프링은 이 경우 UnexpectedRollbackException 런타임 예외를 던진다. 그래서 커밋을 시도했지만, 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려준다.

// 개발자 입장에서 기대하지 않은 롤백이라서 Unexpected다.

- 정리

논리 트랜잭셕이 하나라도 롤백 되면 물리 트랜잭션은 롤백된다.

내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시한다.

외부 트랜잭션을 커밋할 때 롤백 전용 마크를 확인한다.

롤백 전용 마크가 표시되어 있으면 물리 트랜잭션을 롤백하고, UnexpectedRollbackException 예외를 던진다.

- 참고

애플리케이션 개발에서 중요한 기본 원칙은 모호함을 제거하는 것이다.

개발은 명확해야한다.

이렇게 커밋을 호출했는데, 내부에서 롤백이 발생한 경우 모호하게 두면 아주 심각한 문제가 발생한다.

이렇게 기대한 결과가 다른 경우 예외를 발생시켜서 명확하게 문제를 알려주는 것이 좋은 설계이다.

// 여기서는 런타임(언체크) 예외를 터트렸다.

### 스프링 트랜잭션 전파7 - REQUIRES_NEW

이번에는 외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 사용하는 방법에 대해서 알아보자.

외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 각각 별도의 물리 트랜잭션을 사용하는 방법이다.

그래서 커밋과 롤백도 각각 별도로 이루어지게 된다.

이 방법은 내부 트랜잭션에 문제가 발생해서 롤백해도, 외부 트랜잭션에는 영향을 주지 않는다.

반대로 외부 트랜잭션에 문제가 발생해도 내부 트랜잭션에 영향을 주지 않는다.

이 방법을 사용하는 구체적인 예는 이후에 알아보고 지금은 작동 원리를 이해해 보자.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/765ba783-6c65-4045-b819-b6403ea422d4/Untitled.png)

이렇게 물리 트랜잭션을 분리하려면 내부 트랜잭션을 시작할 때 REQUIRED_NEW 옵션을 사용하면 된다.

외부 트랜잭션과 내부 트랜잭션이 각각 별도의 물리 트랜잭션을 가진다.

`별도의 물리 트랜잭션을 가진다는 뜻은 DB 커넥션을 따로 사용한다는 뜻이다.`

이 경우 내부 트랜잭션이 롤백되면서 로직 2가 롤백되어도 로직 1에서 저장한 데이터에는 영향을 주지 않는다.

최종적으로 로직2는 롤백되고, 로직1은 커밋된다.

```java
@Test
void inner_rollback_requires_new(){
    log.info("외부 트랜잭션 시작");
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("outer.isNewTransaction() = {}", outer.isNewTransaction());

    log.info("내부 트랜잭션 시작");
    DefaultTransactionAttribute definition = new DefaultTransactionAttribute();
    definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
    //REQUIRES_NEW는 기존의 트랜잭션이 있다는게 확인되어도 무시하고 새로운 물리 트랜잭션을 만든다.
    TransactionStatus inner = txManager.getTransaction(definition);
    log.info("inner.isNewTransaction = {}", inner.isNewTransaction());

    log.info("내부 트랜잭션 롤백");
    txManager.rollback(inner);

    log.info("외부 트랜잭션 커밋");
    txManager.commit(outer);
}
```

```java
2023-07-27 14:58:03.413  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : Started BasicTxTest in 3.898 seconds (JVM running for 5.632)
2023-07-27 14:58:03.550  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 시작
2023-07-27 14:58:03.552 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2023-07-27 14:58:03.552 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@627597596 wrapping conn0: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA] for JDBC transaction
2023-07-27 14:58:03.554 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@627597596 wrapping conn0: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA] to manual commit
2023-07-27 14:58:03.555  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : outer.isNewTransaction() = true
2023-07-27 14:58:03.555  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 시작
2023-07-27 14:58:03.556 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Suspending current transaction, creating new transaction with name [null]
2023-07-27 14:58:03.556 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1120229752 wrapping conn1: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA] for JDBC transaction
2023-07-27 14:58:03.556 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1120229752 wrapping conn1: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA] to manual commit
2023-07-27 14:58:03.557  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : inner.isNewTransaction = true
2023-07-27 14:58:03.557  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 롤백
2023-07-27 14:58:03.557 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction rollback
2023-07-27 14:58:03.557 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Rolling back JDBC transaction on Connection [HikariProxyConnection@1120229752 wrapping conn1: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA]
2023-07-27 14:58:03.557 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1120229752 wrapping conn1: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA] after transaction
2023-07-27 14:58:03.557 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Resuming suspended transaction after completion of inner transaction
2023-07-27 14:58:03.558  INFO 23732 --- [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 커밋
2023-07-27 14:58:03.558 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2023-07-27 14:58:03.558 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@627597596 wrapping conn0: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA]
2023-07-27 14:58:03.558 DEBUG 23732 --- [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@627597596 wrapping conn0: url=jdbc:h2:mem:123f360e-e429-48f3-9dd9-0a0aa9eeb7a2 user=SA] after transaction
2023-07-27 14:58:03.585  INFO 23732 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
```

- 외부 트랜잭션 시작

외부 트랜잭션을 시작하면서 conn0을 획득하고 manual commit으로 변경해서 물리 트랜잭션을 시작한다.

외부 트랜잭션은 신규 트랜잭션이다. (outer.isNewTransaction() = true)

- 내부 트랜잭션 시작

내부 트랜잭션을 시작하면서 conn1을 획득하고 manual_commit으로 변경해서 물리트랜잭션을 시작한다.

내부 트랜잭션은 외부 틀랜잭션에 참여하는 것이 아니라, PROPAGATION_REQUIRES_NEW 옵션을 사용했기 때문에 완전히 새로운 신규 트랜잭션으로 생성된다.

(inner.isNewTransaction() = true)

- 내부 트랜잭션 롤백

내부 트랜잭션을 롤백한다.

내부 트랜잭션은 신규 트랜잭션이기 때문에 실제 물리 트랜잭션을 롤백한다.

내부 트랜잭션은 conn1을 사용하므로 conn1에 물리 롤백을 수행한다.

- 외부 트랜잭션 커밋

외부 트랜잭션을 커밋한다.

외부 트랜잭션은 신규 트랜잭션이기 때문에 실제 물리 트랜잭션을 커밋한다.

외부 트랜잭션은 conn0을 사용하므로 conn0에 물리 커밋을 수행한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/91bb6890-7862-476c-a593-ca225a6886da/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a09a9a7f-0a0a-4207-b869-0d5965d9d9b8/Untitled.png)

- 요청 흐름 - 외부 트랜잭션
1. txManager.getTransaction()을 호출해서 외부 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.
3. 생성한 커넥션을 수동 커밋 모드 “setAutoCommit(false)” 로 설정한다. - 물리 트랜잭션 시작
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨있다.

isNewTransaction을 통해 신규 트랜잭션 여부를 확인할 수 있다.

트랜잭션을 처음 시작했으므로 신규 트랜잭션이다. → true

1. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다.

- 요청 흐름 - 내부 트랜잭션
1. REQUIRES_NEW 옵션과 함께 txManager.getTransaction()을 호출해서 내부 트랜잭션을 시작한다.
    
    트랜잭션 매니저는 REQUIRES_NEW 옵션을 확인하고, 기존 트랜잭션에 참여하는 것이 아니라 새로운 트랜잭션을 시작한다.
    
2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.
3. 생성한 커넥션을 수동 커밋 모드 (setAutoCommit(false)로 설정한다. - 물리 트랜잭션 시작
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
5. 트랜잭션 매니저는 신규 트랜잭션의 생성한 결과를 반환한다. → isNewTransaction == true
6. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저에 있는 con2 커넥션을 획득해서 사용한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/358d8a9e-22d3-4bff-a73c-a6242a2fa72d/Untitled.png)

- 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다.( 로직2에 문제가 있어 롤백한다고 가정)
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 현재 내부 트랜잭션은 신규 트랜잭션이다.

따라서 실제 롤백을 호출한다.

1. 내부 트랜잭션이 con2 물리 트랜잭션을 롤백한다.
    - 트랜잭션이 종료되고, con2는 커넥션 풀에 반납된다.
    - 이때 con1의 보류가 끝나고 다시 사용한다.

- 응답 흐름 - 외부 트랜잭션
1. 외부 트랜잭션에 커밋을 요청한다.
2. 외부 트랜잭션은 신규 트랜잭션이기 때문에 물리 트랜잭션을 커밋한다.
3. 이때 rollbackOnly 설정을 체크한다.  rollbackOnly 설정이 없으므로 커밋한다.
4. 본인이 만든 con1 커넥션을 통해 물리 트랜잭션을 커밋한다.
    - 트랜잭션이 종료되고, con1은 종료되거나, 커넥션 풀에 반납된다.

- 정리

REQUIRES_NEW 옵션을 사용하면 물리 트랜잭션이 따로 시작된다.

REQUIRES_NEW를 사용하면 데이터베이스 커넥션이 2개 사용된다는 점을 주의해야 한다.

(보류 상태로 두기 때문에, 로직이 모두 끝날 때까지 계속 2개를 사용하는 상태에 있는 것이다.)

`// 조심해야 된다고 한다.`

// 실제로 고객이 요청을 했는데, 로직2가 오래걸린다고 했을때,

// 서버가 병목현상이 생겨서 보니까, 500명의 고객이 동시에 1000개의 커넥션을 실행시키고 있어서 심각한 오류가 발생할 수 있다고 한다.

`// DB에는 한계를 커넥션 풀 한계를 500개로 설정해놨는데, 1000개를 불러오면서 DB 내에서 계속해서 장애가 발생하는 경우가 있다.`

`// 실제로 이런일이 많지는 않은데, 트래픽을 많이 받아오는 곳에서는 조심해야 한다고 한다.`

### 스프링 트랜잭션 전파8 - 다양한 전파 옵션

스프링은 다양한 트랜잭션 전파 옵션을 제공한다.

전파 옵션에 별도의 설정을 하지 않으면 REQUIRED가 기본으로 사용된다.

참고로 실무에서는 대부분 REQUIRED 옵션을 사용한다.

`그리고 아주 가끔 REQUIRES_NEW를 사용하고, 나머지는 거의 사용하지 않는다.`

`그래서 나머지 옵션은 이런 것이 있다는 정도로만 알아두고 필요할 때 찾아보자.`

- REQUIRED

가장 많이 사용하는 기본 설정이다. 기존 트랜잭션이 없으면 생성하고, 있으면 참여한다.

트랜잭션이 필수라는 으미로 이해하면 된다. (필수이기 떄문에 없으면 만들고, 있으면 참여한다.)

기존 트랜잭션 X → 새로운 트랜잭션 생성

기존 트랜잭션 O → 기존 트랜잭션에 참여

- REQUIRES_NEW

항상 새로운 트랜잭션을 생성한다.

기존 트랜잭션 X → 새로운 트랜잭션을 생성한다.

기존 트랜잭션 O → 새로운 트랜잭션을 생성한다.

- SUPPORT

트랜잭션을 지원한다는 뜻이다.

기존 트랜잭션이 없으면, 없는대로 진행하고, 있으면 참여한다.

기존 트랜잭션 X → 트랜잭션 없이 진행한다.

기존 트랜잭션 O → 기존 트랜잭션에 참여한다.

- NOT_SUPPORT

트랜잭션을 지원하지 않는다는 의미이다.

기존 트랜잭션 X → 트랜잭션 없이 진행한다.

기존 트랜잭션 O → 기존 트랜잭션에 참여한다. (기존 트랜잭션은 보류한다.)

- MANDATORY

의무사항이다. 트랜잭션이 반드시 있어야 한다.

기존 트랜잭션이 없으면 예외가 발생한다.

기존 트랜잭션 X → IllegalTransactionStateException 예외 발생

기존 트랜잭션 O → 기존 트랜잭션에 참여한다.

- NEVER

트랜잭션을 사용하지 않는다는 의미이다.

기존 트랜잭션이 있으면 예외가 발생한다.

기존 트랜잭션도 허용하지 않는 강한 부정의 의미로 이해하면 된다.

기존 트랜잭션 X → 트랜잭션 없이 진행함

기존 트랜잭션 O → IllegalTransactionStateException 예외 발생

- NESTED

기존 트랜잭션 X → 새로운 트랜잭션을 생성한다.

기존 트랜잭션 O → 중첩 트랜잭션을 만든다.

- 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않는다.
- 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있다.
- 외부 트랜잭션이 롤백되면 중첩 트랜잭션도 함께 롤백된다.

- 참고
    
    JDBC savepoint기능을 사용한다. DB 드라이버에서 해당 기능을 지원하는지 확인이 필요하다.
    
    중첩 트랜잭션은 JPA에서는 사용할 수 없다.
    
- 트랜잭션 전파와 옵션

isolation, timeout, readOnly는 트랜잭션이 처음 시작될 때만 적용된다.

트랜잭션에 참여하는 경우에는 적용되지 않는다.

예를 들어서 REQUIRED를 통한 트랜잭션 시작, REQUIRES_NEW를 통한 트랜잭션 시작 시점에만 적용된다.

REQUIREDS_NEW는 새로 생성하므로 isolation,timeout,readonly는 당연히 적용된다.

### 정리

- 왜 트랜잭션 전파를 배워야 하는가?

실무에서 트랜잭션을 여러개 실행할 때 트랜잭션이 꼬이는 경우가 발생하는데, 이때 트랜잭션이 어떻게 작동되는지 모르면

영한님 말로는 하루 이틀을 그냥 에러 고민만 하다가 그냥 날려보낸다고 한다.

트랜잭션이 동시에 여러개 실행되었을 때 처리 방식을 미리 배워두고 잘 처리하기 위해서 배운다.

- 트랜잭션 전파란?

트랜잭션 전파는 하나의 로직내에서 2개 이상의 트랜잭션이 실행될 때 트랜잭션을 어떻게 처리해야할지 방법을 결정하는 것이다.

// 쉽게 생각해서 트랜잭션 2개 붙일지 말지 결정하는거다.

1. 스프링 트랜잭션 전파 - 기본에서는 스프링이 어떻게 트랜잭션을 전파하는지에 대해서 배운다.

기본에서는 간단하게 코드로 @Transactional을 사용하지 않고 트랜잭션이 동작하는지 알아보았다.

1. 스프링 트랜잭션 전파 - 트랜잭션 두 번 사용 에서는 스프링이 한 메서드 내에서 2개의 트랜잭션을 각각 실행할 때를 알아보았다.

그냥 새로운 커넥션을 생성해서 따로 따로 잘 처리하는 모습을 보여준다.

1. 스프링 트랜잭션 전파 - 전파 기본 ,예제

스프링은 이해하기 편하도록 여기서 트랜잭션이 크게 하나 물리 트랜잭션과 내부에서 발생하는 작은 논리 트랜잭션으로 나누어 설명하는데,

스프링에서는 Default 전파 전략으로 트랜잭션이 한 메서드내에 2번 실행되면, 하나의 큰 물리 트랜잭션으로 묶고, 내부에는 논리 트랜잭션을 놓는다.

그리고 각 논리 트랜잭션은 Paticipating을 하면서 그냥 쭉 이어나간다.

1. 스프링 트랜잭션 전파 - 외부 롤백

외부 메서드에서 롤백이 되면 끝나는 시점에 롤백이 되기 때문에 내부의 내용은 반영되지 않고 그냥 일반적으로 롤백이 처리된다.

1. 스프링 트랜잭션 전파 - 내부 롤백

내부 메서드에서 롤백이 호출되면, rollback-only = true를 flag로 세워놓고, 외부 메서드에 커밋까지 실행한다.

하지만 물리 트랜잭션 커밋이 시작될 때, rollback-only를 확인하고 전체를 다시 롤백 시켜버린다.

`중간에 끝내는게 아니라 로직 끝까지 간다는것만 알고있자.`

1. 스프링 트랜잭션 전파 - REQUIRES_NEW

원래는 물리 트랜잭션 하나안에 논리 트랜잭션이 참여하는 형태였다면,

각 물리 트랜잭션을 따로 생성하여 서로 전혀 영향을 미치지 말아야 할때 사용한다.

1. 스프링 트랜잭션 전파 - 다양한 전파옵션

그냥 필요하면 찾아보자, 거의 안쓴다.

부가적으로 AOP와 관련이 없도록 직접 getTransaction()을 사용해서 불러온다.

AOP에서는 트랜잭션 2개 동시에 진행되는 방법을 처리할 수 없어서 (나중에 고급편에서 배운다고함)

우선에는 그냥 서비스를 2개로 나누어서 처리하도록 할 수 밖에 없다고 한다.
