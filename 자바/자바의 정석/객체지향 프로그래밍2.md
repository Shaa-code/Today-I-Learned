# 객체지향 프로그래밍2

## 상속(Inheritance)

### 상속이란?

기존의 클래스를 재사용하여 새로운 클래스를 작성하기위한 행위.

### 상속을 사용하는 이유

적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리하기 위해서.

즉, 코드의 추가 및 변경을 용이하게 하기 위해서 사용한다.

객체 지향의 특징인

코드의 재사용성, 코드의 중복제거, 생산성과 유지보수에 크게 기여하기때문에 중요하다.

Java에서 상속을 구현하는 방법

```java
class Child extends Parent {...} // Chiled -> Parent로 기억하면 쉬울듯 하다
```

```java
조상 클래스 = 부모(Parent)클래스 = 상위(Super)클래스 = 기반(Base)클래스
자손 클래스 = 자식(Child)클래스 = 하위(Sub)클래스 = 파생된(Derived)클래스
```

클래스가 복잡해지면, 상속관계도를 그려서 확인하면 보다 쉽게 이해할 수 있다.

상속은 햇갈리기 쉽다.

Parent가 상속한다. 그리고 Parent가 더 작은 집합을 가진다. (상속하기)

Child는 상속받는다. 그리고 Child는 더 큰 집합을 가진다. (상속받기)

**생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.**

**자손 클래스의 멤버 개수는 조상클래스보다 항상 같거나 많다.**

접근제어자(Access Modifier)가 private 또는 default인 멤버들은 상속되지 않는게 아니라,

상속은 받지만 자손클래스로부터 접근이 제한되는것이다.

이전에 배운 초기화 블록(Initialization Block)과 비슷하게 사용된다.

### 초기화 블록을 사용한 중복제거와 상속을 사용한 중복제거의 차이는 무엇일까?

한번 생각해보자.

초기화 블럭의 목적은 중복된 초기화를 없애기 위함,

상속은 중복된 선언을 하지 않기 위함인것같다.

초기화 블록에서는 변수선언이 안된다.

상속은 이미 선언된 변수를 끌어다 쓰는것이다.

당연하게도 자손클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 클래스간의 관계 - 포함관계

상속 이외에도 클래스를 재사용하는 또 다른 방법이 있다.

클래스 간에 ‘포함(Composite)”관계를 맺어 주는것이다.

```java
class Circle{
    int x;
    int y;
    int r;
}

->

class Circle {
    Point c = new Point();
    int r;
}
```

### 클래스간의 관계 결정하기

생각해보면 상속과 포함관계 둘중 무엇을 쓸지 고민된다.

정답은 없지만, `사람이 이해하기 쉬운 직관적인 이해를 기준으로 한다.`

```java
class Circle {
    Point c = new Point();
    int r;
}

==

class Circle extends Point {
    int r;
}
```

is -a 관계이면, 상속을 쓰는게 이해하기 편하고

has -a 관계이면, 포함관계로 쓰는게 이해하기 편하다.

ex)

Circle is a Point

Circle has a Point

`프로그램의 모든 클래스를 분석하여 가능한 많은 관계를 맺도록 노력해서 코드의 재사용성을 높여야한다.`

 

```java
import java.util.*;

class VarEx1 {
    public static void main(String[] args){
    Point[] p1 = {  new Point(100,100),
                    new Point(140,50),
                    new Point(200,100) };

    Triangle t = new Triangle(p1);
    Circle c = new Circle(new Point(150,150), 50);

    t.draw();
    c.draw();

    }
}

class Shape{
    String color = "black";
    void draw(){
        System.out.println(color);
    }
}

class Point{
    int x,y;

    Point(){
        this(0,0);
    }

    Point(int x, int y){
        this.x = x;
        this.y = y;
    }

    String GetXY(){
        return "("+x+","+y+")";
    }

}

class Circle extends Shape{

    Point p1;
    int r=0;

    Circle(){
        this(new Point(0,0),100);
    }

    Circle(Point center,int radius){
        this.p1 = center;
        this.r = radius;
    }
}

class Triangle extends Shape{
    Point[] p = new Point[3];

    Triangle(Point[] p){
        this.p = p;
    }

    void draw(){
        System.out.printf("[p1=%s, p2=%s, p3=%s, color = %s%n",p[0].GetXY(),p[1].GetXY(),p[2].GetXY(),color);
    }
}
```

Circle c = new Circle(new Point(150, 150), 50); 인자 자체를 new Point로 바로 선언한다.

Point[] p1 = { new Point(100, 200), new Point( 300,400), new Point(500,600) ; }

배열은 이렇게 받도록 한다.

```java
class VarEx1 {
    public static void main(String[] args){
        Deck d = new Deck();
        Card c = d.pick(0);
        System.out.println(c);

        d.shuffle();
        c = d.pick(0);
        System.out.println(c);
    }
}

class Deck{
    final int CARD_NUM = 52;
    Card cardArr[] = new Card[CARD_NUM];

    Deck(){
        int i=0;
        for (int k=Card.KIND_MAX; k > 0; k--)
            for (int n=0; n < Card.NUM_MAX ; n++)
                cardArr[i++] = new Card(k,n+1);
    }

    Card pick(int index){
        return cardArr[index];
    }

    Card pick(){
        int index = (int)(Math.random() * CARD_NUM);
        return pick(index);
    }

    void shuffle(){
        for(int i = 0; i < cardArr.length; i++){
            int r = (int)(Math.random() * CARD_NUM);

            Card temp = cardArr[i];
            cardArr[i] = cardArr[r];
            cardArr[r] = temp;

        }
    }
}

class Card {
    static final int KIND_MAX = 4;
    static final int NUM_MAX = 13;
    static final int SPADE = 4;
    static final int DIAMOND = 3;
    static final int HEART = 2;
    static final int CLOVER = 1;
    int kind;
    int number;

    Card() {
        this(SPADE, 1);
    }

    Card(int kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    public String toString() {
        String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
        String numbers = "0123456789XJQK";
        return kinds[this.kind] + " " + " " + numbers.charAt(this.number);
    }
}

```

하나하나 직접 메서드를 만들어보면, 논리구조를 조금 더 확실히 이해할 수 있다.

Card객체에 실제로 저장된 것은 객체가 아니라 객체의 주소이다.                    

```java
System.out.println(c);
System.out.println(c.toString());
```

두가지는 같은 결과 값을 얻는다. 

toString자체가 Object클래스에 정의된 것으로 참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리한다.

## 단일 상속

C++에서는 여러 조상 클래스로부터 상속받는것이 가능한 ‘다중상속’을 허용하지만 자바에서는 오직 단일 상속만을 허용한다.

왜 단일 상속만을 사용할까?

1. 클래스간의 관계가 매우 복잡해지기 때문.
2. 서로 다른 클래스로 부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없기 때문.

즉, 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들기 위해서 사용한다.

```java
class Tv{
    boolean power;
    int channel;
    void power() {power = !power;}
    void channelUp() { ++channel;}
    void channelDown() {--channel;}
}

class VCR{
    boolean power;
    int counter = 0;
    void power() {power = !power;}
    void play() {}
    void stop() {}
    void rew() {}
    void ff() {}
}

class TVCR extends Tv{
    VCR vcr = new VCR();
    void play(){
        vcr.play();
    }
    void stop() {
        vcr.stop();
    }
    void rew() {
        vcr.rew();
    }
    void ff() {
        vcr.ff();
    }
}
```

다중상속과 비슷하게 구현하려면, 하나의 조상을 받고 포함관계로 나타내면 된다.

보는것처럼 TVCR에서 Tv만 단일 상속후 VCR은 포함관계로 객체를 생성해서 받는다.

그렇게 하면, VCR클래스의 메서드의 내용이 변경되어도 TVCR클래스의 메서드들 또한 변경된 내용이 적용되는 결과를 얻을 수 있다.

### Object Class - 모든 클래스의 조상

Object클래스는 모든 클래스 상속 계층도의 최상위에 있는 조상클래스이다.

다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

```java
class Tv {} -> class Tv extends Object {}
```

컴파일시에 컴파일러는 위의 코드를 자동적으로 ‘extends Object’를 추가하여 Tv클래스가 Object클래스로 부터 상속받도록 한다.

하지만 이미 어떤 클래스로부터 상속받도록 작성된 클래스에 대해서는 컴파일러가 ‘extends Object’를 추가하지 않는다.

```java
class Tv {} -> class CaptionTv extends Tv{}
```

CaptionTv → Tv → Object

## 오버라이딩(Overriding)

### 오버라이딩이란?

조상클래스로 부터 상속받은 메서드의 내용을 변경하는것을 ‘오버라이딩’이라고 한다.

### 오버라이딩의 조건

자손 클래스에서 오버라이딩하는 메서드는 조상클래스의 메서드와 이름이 같아야한다.

- 이름이 같아야한다.
- 매개변수가 같아야한다.
- 반환타입이 같아야한다.

JDK1.5부터 ‘공변 반환타입(covariant return type)’이 추가되어, 반환타입을 자손 클래스의 타입으로 변경하는것은 가능하도록 조건이 완화되었다.

다만 접근 제어자(Access Modifier) 예외(Exception)은 제한된 조건하에서만 다르게 변경할 수 있다.

1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
    
    public → protected → (default) → private
    
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
    
    ```java
    class Parent{
        void parentMethod() throws IOException, SQLException{
        }
    }
    
    class Child extends Parent{
        void parentMethod() throws Exception{
        }
    }
    ```
    

단순히 선언된 갯수가 아니다. Exception은 모든 예외의 최고 조상이고 가장 많은 개수의 예외를 던질 수 있도록 선언한것이다.

그래서 보이는것은 Exception 1개이지만, 논리상으로는 모든 예외들로 인식되기 때문에 잘못된 오버라이딩이다.

1. 인스턴스 메서드를 static 또는 그 반대로 변경할 수 없다.
    
    조상클래스에 정의된 static메서드를 자손클래스에서 똑같은 이름의 static메서드로 정의할 수 있는가?
    
    가능하다.
    
    `하지만 이것은 각 클래스에 별개의 static메서드를 정의한 것일 뿐 오버라이딩이 아니다.`
    
    static멤버들은 자신들이 정의된 클래스에 독립되어 묶여있다고 생각하자.
    

### 오버로딩 vs 오버라이딩

오버로딩(Overloading) : 기존에 없는 새로운 메서드를 정의하는것 → New

오버라이딩(Overriding) : 상속받은 메서드의 내용을 변경하는것  → Modify

### super (복습필요)

부모클래스의 변수 명과 자식클래스의 변수 명이 같을때, 구분시켜주는 참조변수이다. 

부모클래스의 변수를 가지고 온다.

```java
class VarEx1 {
    public static void main(String[] args){
        Child c = new Child();
        c.method();
    }
}

class Parent{
    int x = 10;
}

class Child extends Parent{
    int x = 20;
    void method(){
        System.out.println(x);
        System.out.println(this.x);
        System.out.println(super.x);
    }
}
```

super는 메서드에도 적용이 가능하다.

```java
class Point{
    int x;
    int y;

    String getLocation(){
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;
    String getLocation() {
        //return "x :" + x + ", y: " + y + " , z :" + z;
        return super.getLocation() + ", z:" + z;
    }
}
```

조상클래스에 선언된 메서드에 내용을 추가한다면 super를 사용하는것이 좋다.

→ 당연하게도 여러번 수정하지 않아도 되기 때문이다.

`this와 super는 static 메서드에서는 사용할 수 없고 인스턴스 메서드에서만 사용할 수 있다.`

### 생성자의 첫줄에서 생성자를 호출해야하는 이유

super또한 this와 같이 생성자의 첫줄에서 위치되어야한다.

`자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야한다.`

이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 거술러 올라가면서 계속 반복된다.

마지막으로 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝난다.

그래서 Object 클래스를 제외한 모든 클래스의 생성자는 첫줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야한다.

그렇지 않으면 컴파일러는 생성자의 첫줄에 super();를 자동적으로 추가한다.

```java
import java.util.*;

class VarEx1 {
    public static void main(String[] args){
        Point3D p3 = new Point3D(1,2,3);
    }
}

class Point {
    int x, y;

    Point(int x, int y){
        //super(); -> Object()
        this.x = x;
        this.y = y;
    }

    String getLocation(){
        return "x :" + x + ", y:"+ y;
    }
}

class Point3D extends Point{
    int z;

    Point3D(int x, int y, int z){
        //기본 : super(); -> 매개변수 : super(x,y);
        this.x = x;
        this.y = y;
        this.z = z;
    }

    String getLocation(){
        return super.getLocation() + "z : " + z;
    }
}
```

이 상태에서는 오류가 난다. 이유를 잘 찾아보자. 

super()는 Point3D클래스의 조상인 Point클래스의 기본 생성자인 Point()를 뜻한다.

하지만 Point클래스에는 기본 생성자가 정의되어 있지 않으므로 super(x,y)를 추가해주면 된다.

## package 와 import

### 패키지(Package)

패키지란? → 클래스의 묶음이다.

패키지에는 클래스 또는 인터페이스를 포함시킬수 있다.

단순히 클래스이름으로 구분했지만, 사실 클래스의 실제 이름(full name)은 패키지명을 포함한 것이다.

String의 실제이름은 java.lang.String이다.

패키지가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.

클래스 파일들을 압축한것이 jar파일(*.jar)이다.

### 패키지의 선언

package 패키지명;

주석과 공백을 제외한 첫 번째 문장이어야 하며, 하나의 소스파일에 단 한번만 선언될 수 있다.

패키지명은 대소문자 모두 허용하지만, 클래스명과 쉽게 구분하기 위해서 소문자로 하는것을 원칙으로 하고있다.

모든 클래스는 반드시 하나의 패키지에 포함되어야한다.

그럼에도 불구하고 지금까지 소스파일을 작성할 때 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는 자바에서 기본적으로 제공하는 ‘이름없는 패키지(unnamed package)’때문이다.

소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 ‘이름 없는 패키지’에 속하게 된다.

```java
C:\Users\Shaa\IdeaProjects\Helloworld\src> javac -d . VarEx1.java
```

‘-d’옵션은 소스파일에 지정된 경로를 통해 패키지의 위치를 찾아서 클래스파일을 생성한다.

-d 뒤에는 해당 패키지의 루트 디렉토리의 경로를 적어준다.

CLASSPATH를 설정해줘야만, 실행시 JVM이 위의 클래스를 찾을 수 있다.

classpath는 컴파일러나 JVM등이 클래스의 위치를 찾는데 사용되는 경로이다.

```java
.;C:\Users\Shaa\IdeaProjects\Helloworld\src\
```

맨앞에 ‘.;’를 추가한 이유는 현재의 디렉토리(.)를 클래스패스에 포함시키기 위해서다.

jar파일을 클래스 패스에 추가하기 위해서는 경로와 파일명을 적어주어야한다.

```java
C:\WINDOWS> SET CLASSPATH = .;C:\Users\Shaa\IdeaProjects\Helloworld\src\com\codechobo\book\util.jar;
```

### 적용된지 확인하는법

C:\Windows 에서 echo %classpath%를 해보면 경로가 나온다.

---
### 오류발생

**Error: A JNI error has occurred, please check your installation and try again**

a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 52.0

버전이 서로 맞지 않아서 발생하는 문제이다.

**1. javac 명령어에 "--release 8"을 추가하여 낮은 버전으로 자바 버전을 맞춘다.**

(빠름, 일시적)

**2. 환경변수를 수정하여 java와 javac 명령어가 사용하는 자바의 버전을 맞춘다.**

(귀찮음, 비교적 영구적)

<참고>[https://hoohaha.tistory.com/41](https://hoohaha.tistory.com/41)

---

JDK에 기본적으로 설정되어있는 클래스패스를 이용하면 위의 예제에서와 같이 클래스패스를 따로 설정하지 않아도 된다.

새로 추가하고자 하는 클래스를 ‘JDK설치디렉토리\jre\classes에 넣으면 따로 이름을 넣지 않아도된다.

jre디렉토리 아래의 classes디렉토리는 JDK설치 시에 자동으로 생성되지 않으므로 사용자가 직접 생성해야한다.

jar파일인 경우  ‘JDK설치디렉토리\jre\lib\ext’에 넣으면 된다.

또는 실행 시에 ‘-cp’옵션을 이용해서 일시적으로 클래스패스를 지정해 줄수도 있다.

```java
C:\WINDOWS>java -cp C:\Users\Shaa\IdeaProjects\Helloworld\src com.codechobo.book.VarEx1
```

### Import문

import문은 프로그램의 성능에 전혀 영향을 미치지 않는다.

import문을 많이 사용하면 컴파일 시간이 아주 조금 더 걸릴 뿐이다.

```java
import 패키지명.클래스명;
import 패키지명.*;
```

클래스이름을 *을 사용하면, 컴파일러는 해당 패키지에서 일치하는 클래스이름을 찾아야하는 수고를 더해야 한다.

`실행 시 성능상의 차이는 전혀없다.`

```java
import java.util.Calendar;
import java.util.Date;
import java.util.ArrayList;

->

import java.util.*;
```

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class VarEx1 {
    public static void main(String[] args){
        Date today = new Date();

        SimpleDateFormat date = new SimpleDateFormat("yyyy/MM/dd");
        SimpleDateFormat time = new SimpleDateFormat("hh:mm:ss a");

        System.out.println(date.format(today));
        System.out.println(time.format(today));
    }
}
```

```java
java.util.Date Today = new java.util.Date()

java.text.SimpleDateFormat date = new java.text.SimpleDateFormat(”yyyy/MM/dd”);

java.text.SimpleDateFormat time = new java.text.SimpleDateFormat(”hh:mm:ss a”);
```

import문으로 패키지를 지정하지 않으면 모든 클래스앞에 패키지명을 붙여야한다.

지금까지 System과 String같은 java.lnag패키지의 클래스들을 패키지명 없이 사용할 수 있었던 이유는 모든 소스파일에는 묵시적으로 import java.lang.*;이 선언되어있기 때문이다.

java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 따로 import문으로 지정하지 않아도 된다.

### static import문

static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

사용이유 : `특정 클래스의 static멤버를 자주 사용할 때 쓰기 위해서.`

```java
import static java.lang.Integer.*; // Integer클래스의 모든 static메서드
import static java.lang.Math.random; //괄호를 붙이지 않고 선언
import static java.lang.System.out; // System.out을 out만으로 참조가능
```

```java
import static java.lang.System.out;
import static java.lang.Math.*;

class VarEx1 {
    public static void main(String[] args){
        out.println(random());
        out.println(PI);
    }
}
```

## 제어자(modifier)

### 제어자란?

제어자(modifier)는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

접근제어자 : public, protected, default, private

그외 : static final, abstract, native, transient, sysnchronized, vlatile, strictfp

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는것이 가능하다.

제어자들 간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.

### static

- 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
    - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    - 클래스가 메모리에 로드될 때 생성된다.
- 메서드
    - 인스턴스를 생성하지 않고도 호출이 가능한 static메서드가 된다.
    - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.
- static초기화 블럭
    
    클래스가 메모리에 로드될때 단 한번만 수행되며, 주로 클래스변수(static변수)를 초기화하는데 주로 사용된다.
    

### final

- 클래스
    - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
    - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
- 메서드
    - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
- 멤버변수,지역변수
    
    변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 된다.
    
    간략화 : 상속 금지, 오버라이딩 금지, 변경금지(상수로 선언)
    

### 생성자를 이용한 final멤버 변수의 초기화

final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만,

인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.

이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버 변수가 다른값을 갖도록 하는것이 가능하다.

```java
class VarEx1 {
    public static void main(String[] args) {
        Card c1 = new Card("HEART",10); -> 이렇게 생성자로 바로 초기화 할수도 있다.
    }
}

class Card{
    final String KIND; // 여기서 바로 초기화해도 된다.
    final int NUMBER; // 여기서 바로 초기화해도 된다.

    Card(String kind, int num){
        this.KIND = kind;
        this.NUMBER = num;
    }

    Card(){
        this("HEART",1);
    }

    public String toString(){
        return KIND+ " " + NUMBER;
    }
}
```

객체를 생성할때, 생성자를 이용하여서 final을 초기화 할수도 있다는 의미이다.

Tip) 카드의 값을 변경할때에 오류가 발생한다면 큰 오류가 될수 있다. 반면에, 오류가 나더라도 순서를 바꾸는 방법으로 로직을 만들었다면 오류가 발생하더라도 조금 더 안전한 오류일 수 있다.

### abstract

- 클래스

클래스 내에 추상 메서드가 선언되어 있음을 의미한다.

- 메서드

선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다.

추상클래스는 아직 완성되지 않은 메서드가 존재하는 ‘미완성 설계도’이므로 인스턴스를 생성할 수 없다.

이 클래스자체로는 쓸모가 없지만, 다른 클래스가 이 클래스를 상속받아서 일부의 원하는 메서드만 오버라이딩해도 된다는 장점이 있다. 

만일 이 클래스가 없다면 아무런 내용도 없는 메서드를 잔뜩 오버라이딩해야한다.

### 접근제어자 (Access Modifier)

private : 같은 클래스 내에서만 접근이 가능하다.

default : 같은 패키지 내에서만 접근이 가능하다.

protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.

public : 접근 제한이 전혀없다.

![Untitled](https://user-images.githubusercontent.com/70310271/168010340-dc43cb3c-f27c-42a9-b23c-4c7fe653f85d.png)

### 접근 제어자를 이용한 캡슐화

데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는것이 필요하다.

이것을 데이터 감추기(data hiding)이라고 하며, 객체지향개념의 캡슐화(encapsulation)에 해당한다.

또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 부분을 감추기 위해서이다.

사용하는 이유

- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

만일 메서드 하나를 변경해야 한다고 가정했을때, 이 메서드의 접근 제어자가 public이라면, 메서드를 변경한 후에 오류가 없는지 테스트해야하는 범위가 넓다.

그러나 접근 제어자가 default라면 패키지내부만 확인해보면되고, private이면 클래스하나만 살펴보면된다.

→ 이러한 이유로도 사용된다.

```java
class VarEx1 {
    public static void main(String[] args) {
        Time t = new Time(12,35,30);
out.println(t);
        t.hour = 13; // 오류남
        t.setHour(t.getHour()+1);
        System.out.println(t);
    }
}

class Time{
    private int hour,minute,second;

    Time(int hour, int minute, int second){
        setHour(hour);
        setHour(minute);
        setHour(second);
    }

    public int getHour() {
        return hour;
    }

    public void setHour(int hour) {
        if (hour < 0 || hour > 23) return;
        this.hour = hour;
    }

    public int getMinute() {
        return minute;
    }

    public void setMinute(int minute){
        if (minute < 0 || minute > 59) return;
        this.minute = minute;
    }

    public int GetSecond() {
        return second;
    }

    public void SetSecond(int second){
        if (second < 0 || second > 59) return;
        this.second = second;
    }

    public String toString(){
        return hour + ":" + minute + ":" + second;
    }

}
```

보다시피 변수에 범위를 두고싶다면, 조건을 검사하는 메서드를 따로 구현해야한다.

### 생성자의 접근 제어자 (연습해야하는 개념)

생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게된다. 그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```java
class VarEx1 {
    public static void main(String[] args){
        Singleton s = new Singleton();
        Singleton s = Singleton.getInstance();
    }
}

final class Singleton{
    private static Singleton s = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        if(s==null)
            s = new Singleton();
        return s;
    }
}
```

직접 생성자에 접근할 수 없으므로 getInstance메서드를 만들어서 객체를 초기화하는 방식을 사용한다.

### Q1. 왜 private Singleton이 아닌 private static Singleton인가?

static으로 선언해야만, 클래스가 메모리에 올라감과 동시에 인스턴스 변수 s를 생성할것이고,

이후에 getinstance()에서 사용될 수 있기 때문이다.

→ `굉장히 중요하다.`

fianl을 추가하여 상속할 수 없는 클래스라는 것을 알리는것이 좋다.

### 제어자(Modifier)의 조합

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
    
    static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
    
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
    
    클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기때문이다.
    
3. abstract메서드의 접근제어자가 private일 수 없다.
    
    abstract메서드는 자손클래스에서 구현해주어야하는데 접근제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.
    
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
    
    접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다.
