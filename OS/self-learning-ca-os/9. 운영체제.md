## 운영체제를 알아야하는 이유

앞에서 배운 CPU, 메모리, 보조기억장치, 입출력장치 등과 같은 모든 부품들은 모두 `자원이라 볼수 있다.`

### 운영체제란? (운영체제란 특수한 프로그램이다.)

실행할 프로그램에 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 운영체제이다.

운영체제또한 인터넷 브라우저, 게임과 같은 프로그램이다.

그래서 운영체제 또한 여느 프로그램과 마찬가지로 메모리에 적재되어야한다.

다만 운영체제는 매우 특별한 프로그램이기 때문에 항상 컴퓨터가 부팅될 때 메모리 내 “Kernel Space”(커널 영역)이라는 공간에 따로 적재되어 실행된다. 

사용자가 이용하는 응용 프로그램이 적재되는 영역을 “User Space”(사용자 영역)이라고 한다.

즉, 운영체제는 커널 영역에 적재되어 사용자 영역에 적재된 프로그램들에 자원을 할당하고 이들이 올바르게 실행되도록 돕는다.

![Untitled](https://user-images.githubusercontent.com/70310271/211577571-61504a93-ddbf-4969-92cf-91b54c793092.png)

Memo , Web Browser , Game 메모리 주소가 겹치지 않도록 적당한 공간에 프로그램들을 적재해 준건 누구였을까? 바로 운영체제이다.

운영체제는 실행할 프로그램을 메모리에 적재하고, `더 이상 실행되지 않는 프로그램을 메모리에서 삭제하며 지속적으로 메모리 자원을 관리한다.`

이 응용 프로그램들이 실행되려면 반드시 CPU가 필요하다.

어떤 프로그램부터 CPU를 사용하게 할까?

그리고 얼마나 오랫동안 CPU를 이용하게 할까?

이 문제 또한 운영체제가 해결한다. 어느 한 프로그램이 CPU를 독점하면 다른 프로그램들은 올바르게 실행될 수 없기 때문에 운영체제는 최대한 공정하게 여러 프로그램에 CPU자원을 할당한다.

### 운영체제를 알아야하는 이유

1+2를 출력하는 프로그램을 개발한다고 했을때, 이런 간단한 프로그램조차도 운영체제가 없다면 작성하기 조차 매우 어렵다.

프로그램을 메모리에 적재하는 코드, CPU로 하여금 1+2를 더하게 하는 코드, 모니터에 계산 결과를 출력하는 코드를 개발자가 직접 작성해야하기 때문이다.

운영체제가 하드웨어를 조작하고 관리하는 기능들을 제공하기 때문에 개발자는 하드웨어를 조작하는 코드를 직접 작성할 필요가 없이 운영체제의 도움을 받아 간편하게 개발할 수 있다.

개발자는 왜 운영체제를 알아야하는가?

앞으로 우리가 접하게되는 대다수의 오류 메시지의 근원은 운영체제이다.

우리가 작성한 소스코드를 하드웨어가 제대로 실행하지 못하면 운영체제는 우래에게 오류메시지를 띄워준다.

만약 메모리 누수 오류, 잘못된 주소 참조 오류를 운영체제가 보내고 있는데, 프로그래밍 문법만 학습했다면, 어떻게 해결할지 모를것이다.

## 운영체제의 큰 그림

### 운영체제의 심장, 커널

운영체제가 설치된 모든 기기에는 커널이 있다.

어떤 커널을 사용하는지에 따라 우리가 실행하고 개발하는 프로그램이 하드웨어를 이용하는 양상이 달라지고, 결과적으로 컴퓨터 전체의 성능도 달라질 수 있다.

운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스도 있다.

대표적으로 사용자 인터페이스(User Inferface ; UI)가 있다.

`GUI, CLI둘다, 운영체제가 제공하는 서비스이지만, 이는 그저 컴퓨터와 상호작용하기 위한 통로일 뿐 커널에 속한 기능은 아니다.`

실제로 같은 커널을 사용하더라도 사용자 인터페이스는 다를 수 있다.

### 이중 모드와 시스템 호출

`운영체제는 사용자가 실행하는 응용 프로그램이 하드웨어 자원에 직접 접근하는것을 방지하여 자원을 보호한다.`

응용 프로그램이 자원에 접근하기 위해서는 운영체제에 도움을 요청해야한다.

응용 프로그램의 요청을 받은 운영체제는 응용 프로그램 대신 자원에 접근하여 요청한 작업을 수행한다.

![Untitled 1](https://user-images.githubusercontent.com/70310271/211577596-d14c3e25-d1af-4d48-80f6-c885a09edde9.png)

ex) 

1. 응용프로그램이 실행 과정에서 하드디스크에 접근하여 데이터를 저장하려면 운영체제에 도움을 요청한다.
2. 운영체제는 커널 영역 내의 하드디스크에 데이터를 저장하는 코드를 실행하여 응용 프로그램의 작업을 대신 수행해준다.

이러한 문지기 역할은 이중 모드로써 구현된다.

### 이중 모드(Dual Mode)란?

CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널모드로 구분하는 방식이다.

CPU는 명령어를 사용자 모드로써 실행할 수 있고, 커널 모드로써 실행할 수 있다.

- User Mode( 유저 모드 )

운영체제 서비스를 제공받을 수 없는 실행모드.

즉, 커널 영역의 코드를 실행할 수 없는 모드이다.

일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행된다.

사용자 모드로 실행 중인 CPU는 입출력 명령어와 같이 하드웨어 자원에 접근하는 명령어를 실행할 수 없다.

그래서 사용자 모드로 실행되는 일반적인 응용 프로그램은 자원에 접근할 수 없다.

- Kernel Mode( 커널 모드 )

운영체제 서비스를 제공받을 수 있는 실행모드이다.

즉, 커널 영역의 코드를 실행할 수 있는 모드이다.

CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있다.

`운영체제는 커널 모드로 실행되기 때문에 자원에 접근 할 수 있다.`

feat) CPU가 사용자 모드로 사용중인지, 커널 모드로 사용중인지는 플래그 레지스터의 슈퍼바이저 플래그를 보면 알 수 있다.

사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 제공받으려면 운영체제에 요청을 보내 커널 모드로 전환되어어 한다.

이때 운영체제 서비스를 제공받기 위한 요청을 System Call(시스템 콜 ; 시스템 호출)이라고 한다.

사용자 모드로 실행되는 프로그램은 시스템 호출을 통해 커널모드로 전환하여 운영체제 서비스를 제공받을 수 있다.

```java
헷갈리는점

커널 모드는 운영체제가 되는게 아니다.

운영체제 서비스를 제공 받을 수 있는 실행 상태가 될 뿐이다!
```

![Untitled 2](https://user-images.githubusercontent.com/70310271/211577628-3a7b9cf8-5e66-402e-9dac-3d4f54815e40.png)

시스템 호출은 일종의 인터럽트이다.

정확히는 소프트웨어적 인터럽트이다.

인털럽트는 입출력장치에 의해 발생하기도 하지만 인터럽트를 발생시키는 특정 명령어에 의해 발생하기도 하는데, 이를 “소프트웨어 인터럽트”라고 한다.

그래서 CPU가 시스템 호출을 처리하는 순서는 인터럽트 처리 순서와 유사하다.

시스템 호출을 발생시키는 명령어가 실행되면 CPU는 지금까지의 작업을 백업하고, 커널 영역 내에 시스템 호출을 수행하는 코드(인터럽트 서비스 루틴)을 실행한 뒤 다시 기존에 실행하던 응용 프로그램으로 복귀하여 실행을 계속해 나간다.

```java
헷갈린점

1. 커널 모드가 되서 시스템 호출을 하는게 아니다.

시스템 호출을 하면서 커널모드로 전환되는 것이다.
```
![Untitled 3](https://user-images.githubusercontent.com/70310271/211577647-b755b09e-ae9a-4623-b9c9-41f1e5794f7d.png)

1. 하드 디스크에 데이터를 저장하는 시스템 호출을 발생시켜 커널모드로 전환
2. 운영체제 내의 ‘하드 디스크에 데이터를 저장하는 코드’를 실행함으로써 하드 디스크에 접근할 수 있음.
3. 하드 디스크에 접근이 끝났다면 다시 사용자 모드로 복귀하여 실행을 계속해 나감

일반적으로 응용 프로그램은 실행과정에서 운영체제 서비스들을 매우 빈번하게 이용한다.

그 과정에서 빈번하게 시스템 호출을 발생시키고 사용자 모드와 커널 모드를 오가며 실행된다.

### 운영체제의 핵심 서비스

- 프로세스 관리

실행중인 프로그램은 프로세스라고 한다.

일반적으로 하나의 CPU는 한 번에 하나의 프로세스만 실행할 수 있다.

CPU는 이 프로세스들을 조금씩 번갈아가며 실행한다.

CPU는 한 프로세스를 실행하다가 다른 프로세스로 실행을 전환하고,

그 프로세스를 실행하다가 또 다른 프로세스로 실행하는것을 반복한다.

이때 각 프로세스는 상태도, 사용하고자 하는 자원도 다양하다.

입출력장치를 주로 사용하는 프로세스도 있고, 입출력장치는 거의 사용하지 않고 주로 CPU만 사용하는 프로세스도 있다.

당장 실행할 수 있는 프로세스가 있는 반면, 당장 실행이 불가능한 프로세스도 있다.

운영체제는 다양한 프로세스를 일목요연하게 관리하고 실행할 수 있어야한다.

- 자원 접근 및 할당

모든 프로세스는 실행을 위해 자원을 필요로 한다.

운영체제는 프로세스들이 사용할 자원에 접근하고 조작함으로써 프로세스에 필요한 자원을 할당해 준다.

1. CPU

일반적으로 메모리에는 여러 프로세스가 적재되고, 하나의 CPU는 한 번에 하나의 프로세스만 실행할 수 있다.

그래서 하나의 프로세스가 CPU를 이용하고 있다면 다른 프로세스는 기다려야한다.

이에 운영체제는 프로세스들에 공정하게 CPU를 할당하기 위해 어떤 프로세스부터 CPU를 이용하게 할것인지, 얼마나 오래 CPU를 이용하게 할지를 결정할 수 있어야한다. (11장 CPU 스케쥴링)

1. Memory

메모리에 적재된 프로세스들은 크기,주소도 모두 다르다.

같은 프로세스라 할지라도 실행할때마다, 적재되는 주소는 달라질수 있다.

그래서 운영체제는 새로운 프로세스가 적재될 때 마다 어느 주소에 적재해야 할지를 결정해야한다.

때로는 메모리가 이미 꽉차 있어 꼭 실행해야 할 프로세스를 적재할 공간이 없는 경우도 있고, 메모리에 공간이 남았는 데도 불구하고 프로세스를 적재하지 못하는 상황도 발생한다.

운영체제가 프로세스에 어떻게 메모리를 할당하는지, 그리고 메모리가 부족할 경우 이를 어떻게 극복하는지 알아야한다. (14장)

1. I/O Device

`인터럽트 서비스 루틴은 운영체제가 제공하는 기능으로 커널 영역에 있다.`

입출력장치가 발생시키는 하드웨어 인터럽트도 마찬가지이다.

입출력 장치가 CPU에 하드웨어 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업한 뒤 커널 영역에 있는 인터럽트 서비스 루틴을 실행한다.

운영체제는 인터럽트를 처리하는 프로그램, 즉 인터럽트 서비스 루틴을 제공함으로써 입출력 작업을 수행한다.

- 파일 시스템 관리

우린 여러 파일을 열고 생성하고 삭제하고는한다.

이 파일들을 한데 묶어 폴더로 관리하는것 이런 당연해 보이는것도 운영체제가 지원하는 핵심 서비스인 File System이다.

운영체제가 보조기억장치 속 데이터를 어떻게 파일과 디렉토리로 관리하는지도 알아야한다. (15장)

### 가상 머신

우리가 컴퓨터에 설치된 운영체제에서 가상 머신을 설치 및 실행한다면, 그 가상 머신 또한 응용 프로그램이다.

그래서 사용자 모드로 작동한다.

마찬가지로 가상 머신상에 설치된 운영체제 또한 사용자모드로 작동한다.

가상 머신에 설치된 응용프로그램은 운영체제 서비스를 제공받기 위해서는 커널모드로 전환되어야하는데, 가상 머신에 설치된 운영체제도 사용자 모드로 작동하면 운영체제 서비스를 제공받기 어렵다.

![Untitled 4](https://user-images.githubusercontent.com/70310271/211577687-0203e840-6e4c-40c3-b2e6-9dee621b5a65.png)

그래서 가상화를 지원하는 CPU는 커널 모드와 사용자 모드 이외에 가상 머신을 위한 모드인 “Hypervisor Mode”(하이퍼바이저 모드)를 따로 둔다.

이로써 가상 머신 상에서 작동하는 응용 프로그램들은 하이퍼바이저 모드로써 가상 머신에 설치된 운영체제로 부터 운영체제 서비스를 받을 수 있다.

### 시스템 호출의 종류

시스템 호출은 운영체제 서비스를 제공받기 위한 방법이므로, 이것만 잘 파악해도 해당 운영체제의 깊이 이해할 수 있다.

유닉스, 리눅스등의 운영체제의 대표적인 시스템 호출들

| 종류 | 시스템 호출 | 설명 |
| --- | --- | --- |
| 프로세스 관리 | fork() | 새 자식 프로세스 생성 |
|  | execve() | 프로세스 실행(메모리 공간을 새로운 프로그램의 내용으로 덮어씌움) |
|  | exit() | 프로세스 종료 |
|  | waitpid() | 자식 프로세스가 종료할 때까지 대기 |
| 파일 관리 | open() | 파일 열기 |
|  | close() | 파일 닫기 |
|  | read() | 파일 읽기 |
|  | write() | 파일 쓰기 |
|  | stat() | 파일 정보 획득 |
| 디렉터리 관리 | chdir() | 작업 디렉터리 변경 |
|  | mkdir() | 디렉터리 생성 |
|  | rmdir() | 비어있는 디렉터리 삭제 |
| 파일 시스템 관리 | mount() | 파일 시스템 마운트 |
|  | umount() | 파일 시스템 마운트 해제 |

개발자가 작성하는 프로그래밍 언어들은 내부적으로 위와 같은 시스템 호출을 통해 실행된다.

printf도 내부적으로 시스템 호출을 통해 실행되고, scanf도 내부적으로 시스템 호출을 통해 실행된다.

[self-learning-cs/syscalls.html at main · kangtegong/self-learning-cs](https://github.com/kangtegong/self-learning-cs/blob/main/system_calls/syscalls.html)

// 어떤게 있는지 다 찾아보니 소켓도 운영체제에서 연결하는구나..
