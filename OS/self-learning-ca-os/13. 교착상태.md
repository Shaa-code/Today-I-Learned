프로세스를 실행하기 위해서는 자원이 필요한데, 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다린다면 그 어떤 프로세스도 더 이상 진행할 수 없는 교착 상태가 된다.

### 식사하는 철학자 문제(Dining Philosophers Problem)

![Untitled](https://user-images.githubusercontent.com/70310271/212546964-2e68b714-5141-4d2c-9c9a-1d3daf2e7c57.png)

교착상태가 어떤 상황에서 왜 발생하는지 나아가 교착상태를 어떻게 해결할 수 있는지 엿볼 수 있는 가상의 문제시나리오이다.

1. 왼쪽 포크가 사용 가능하면 집어든다.
2. 오른쪽 포크가 사용 가능하면 집어든다.
3. 왼쪽과 오른쪽 포크를 모두 집어들면 정해진 시간 동안 식사를 한다.
4. 식사 시간이 끝나면 오른쪽 포크를 내려 놓는다.
5. 오른쪽 포크를 내려 놓은 뒤 왼쪽 포크를 내려놓는다.
6. 다시 1번 부터 반복한다.

모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들수 없다.

모든 철학자는 다른 철학자가 포크를 내려놓을때 까지 기다린다.

이렇게 일어나지 않을 사건을 기다리며 진행이 멈춰버리는 현상을 교착 상태(Dead Lock)이라고 한다.

교착 상태는 아주 다양한 상황에서 발생한다.

앞서 배운 뮤텍스 락에서도 교착상태는 발생할 수 있다.

ex)

프로세스 A는 임계 구역 진입전 lock1을 잠궜다.

```java
lock1 = true;
while(lock2 == true);
//임계구역 작업
lock1 = false;
```

프로세스 B는 임계구역 진입 전 lock2를 잠궜다.

```java
lock2 = true;
while(lock1 = true);
//임계구역 작업
lock2 = false;
```

교착 상태를 해결법

1. 교착 상태가 발생했을때의 상황을 정확히 표현해봐야한다.
2. 교착 상태가 일어나는 근본적인 이유에 대해 알아야한다.

우선, 교착 상태가 발생했을 떄의 상황을 한 눈에 보기 쉽게 그래프로 표현하는 방법을 알아보자.

### 자원 할당 그래프 (Resource - Allocation Graph)

자원 할당 그래프를 통해 단순하게 표현할 수 있다.

자원 할당 그래프는 어떤 프로세스가 어떤 자원을 사용하고 있고, 또 어떤 프로세스가 어떤 자원을 기다리고 있는지를 표현하는 간단한 그래프이다.

1. 프로세스는 원으로 자원의 종류는 사각형으로 표현한다.

![Untitled 1](https://user-images.githubusercontent.com/70310271/212546981-6ab3a23c-0710-4cf5-99aa-df266f57e11f.png)

1. 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현한다.

![Untitled 2](https://user-images.githubusercontent.com/70310271/212546983-da7129db-41e1-4b7f-9819-a10f23a44c2e.png)

(사용가능한 HDD의 개수는 3개, 사용가능한 CPU의 개수는 2개)

1. 프로세스가 어떤 자원을 할당받아 사용 중이라면 자원에서 프로세스를 향해 화살표 표시를 한다.

![Untitled 3](https://user-images.githubusercontent.com/70310271/212546989-e0d16707-a05b-4f45-8801-0eb3a8db0d41.png)

1. 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표를 표시한다.

![Untitled 4](https://user-images.githubusercontent.com/70310271/212547000-4ce54d69-f1ea-4547-a087-c9850f7146bc.png)

`교착 상태가 발생한 상황은 자원 할당 그래프가 원의 형태를 띄고 있다.`

### 교착 상태 발생 조건

교착 상태가 발생할 조건에는 4가지가 있다.

아래 4가지 조건이 모두 동시에 만족될때 교착 상태가 발생한 가능성이 생긴다.

아래 조건중 하나라도 만족하지 않는다면 교착 상태는 발생하지 않는다.

1. 상호 배제(Mutual Exclusion)

교착 상태가 발생한 근본적인 원인은 해당 자원을 한번에 하나의 프로세스만 이용 가능했기 때문이다.

만일 식사하는 철학자 문제에서 하나의 포크를 여러명이 동시에 사용할 수 있었다면 교착 상태는 발생하지 않는다.

한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때, 즉 상호 배제 상황에서 교착 상태는 발생할 수 있다.

1. 점유와 대기 (Hold and wait)

식사하는 철학자 문제에서 누구도 식사를 이어나갈 수 없었던 이유는 ‘왼쪽 포크를 들고’ 다른 철학자의 포크를 기다렸기 때문이다.

자원을 보유한 채 다른 자원을 기다렸기 때문에 문제가 발생한것이다.

프로세스도 마찬가지로 어떠한 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있다.

자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태를 ‘점유와 대기’라고 한다.

1. 비선점(Non-preemptive)

만일 철학자들 중 누군가가 다른 철학자의 포크를 강제로 빼앗을 수 있었다면 교착 상태는 발생하지 않았다.

이 처럼 교착 상태가 발생하게된 또 하나의 근본적인 문제는 프로세스가 자원을 비선점하고 있었기 때문이다.

1. 원형 대기 (Circular Wait)

교착 상태가 발생한 마지막 이유는 프로세스들과 프로세스가 요청 및 할당받은 자원이 원의 형태를 이루었기 때문이다.

자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 수 있다.

이렇게 프로세스들이 원의 형태로 자원을 대기하는 것을 원형 대기라고 한다.

feat) 자원 할당 그래프가 원의 형태를 띄지 않는다면 교착 상태는 발생하지 않으나, `원의 형태를 띈다고 해서 반드시 교착 상태가 발생하는것은 아니다.`

## 교착 상태 해결 방법

운영체제는 교착 상태를 해결하는 3가지 방법을 가지고 있다.

### 예방

교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착상태를 예방한다.

상호 배제, 점유와 대기, 비선점, 원형 대기중 하나의 조건이라도 만족시키지 않게 한다.

- 상호배제를 없애보자.

상호배제를 없애면, 교착상태를 없앨수는 있지만, 원하는 결과값을 얻지는 못할것이다. (계좌 저장 예제 생각하면된다.)

- 점유와 대기를 없애보자.

점유와 대기를 없애면, 철학자 문제속 포크를 두 개 동시에 들게 하거나, 아니면 아예 들지 못하게 하는것이다.

점유와 대기를 없애면 운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분한다.

이론적으로는 교착 상태를 해결할 수 있지만, 이는 굉장히 비효율적이다.

당장 자원이 필요해도 기다릴 수 밖에 없는 프로세스와 사용되지 않으면서 오랫동안 할당되는 자원을 다수 양산하기 때문에 자원의 활용률이 낮아진다.

또한 많은 자원을 사용하는 프로세스는 불리해진다.

자원을 많이 사용하는 프로세스는 자원을 적게 사용하는 프로세스에 비해 동시에 자원을 사용할 타이밍을 확보하기가 어렵기 때문이다.

이는 결국 많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 기아 현상을 야기할 우려가 있다.

- 비선점 조건을 없애보자.

자원을 이용 중인 프로세스로부터 해당 자원을 빼았을 수 있다.

이 방식은 선점하여 사용할 수 있는 일부 자원에 대해서는 효과적이다.

한 프로세스가 CPU를 이용하다가 일정 시간이 지나면 아직 작업이 모두 끝나지 않았다고 할지라도 다른 프로세스가 CPU를 할당받아 사용할 수 있기 때문이다.

하지만 한 프로세스가 프린터를 이용하는 도중에 다른 프로세스가 프린터 자원을 빼앗아 사용하는건 어렵다.(흠.. 사실 인터럽트만 보내는거라 상관없긴한데,)

그렇기이에 비선점 조건을 없애 모든 자원을 빼앗을 수 있도록하여 교착 상태를 예방하는 방법은 다소 범용성이 떨어지는 방안이다.

- 원형 대기 조건을 없애보자.

원형 대기를 없애는 방법은 간단하다. 모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형 대기는 발생하지 않는다.

ex) 식사하는 철학자 문제에서 모든 포크에 1번부터 5번까지 번호를 붙이고, 철학자들로 하여금 번호가 낮은 포크에서 높은 포크 순으로 집어들게 한다면 원형 대기는 발생하지 않는다.

![Untitled 5](https://user-images.githubusercontent.com/70310271/212547003-6d6ca3f4-9a6a-4436-879d-f6b360da2e3f.png)

원형문제를 직렬 문제로 바꿔서 푸는것이다.

원형대기를 없앰으로써 교착 상태를 예방하는 방식은 앞선 세 방식에 비하면 비교적 현실적이고 실용적인 방식이지만, 단점이 있다.

1. 모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 일은 간단한 작업이 아니다.
2. 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있다.

살펴보면 교착 상태의 발생 조건을 원천적으로 제거하여 교착 상태를 사전에 방지하는 `예방 방식은 교착 상태가 발생하지 않음을 보장할 수는 있지만 여러 부작용이 따른다.`

### 회피

교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식으로 교착 상태를 회피한다.

회피방식에서는 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주한다.

프로세스들에 할당할 수 있는 자원이 충분한 상황에서 프로세스들이 한 두개의 적은 자원만을 요구한다면 교착 상태는 발생하지 않는다.

포크가 1000개 있는 상태에서 철학자들이 한두개의 포크를 요구하면 교착상태는 발생하지 않는다.

포크의 양이 충분하지 않은 상태에서 철학자들이 모두 자신이 요구할 수 있는 최대 포크를 요구하면 교착상태가 발생한다.

그렇기 때문에 `프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법이 교착 상태 회피`이다.

교착 상태를 회피하는 방법을 학습하기 위해서는 안정 상태와 불안정상태, 그리고 안전 순서열이라는 용어를 알아야한다.

- 안정상태(Safe State)

교착상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태

- 불안전 상태(Unsafe State)

교착 상태가 발생할 수 도 있는 상황

- 안전 순서열(Safe Sequence)

교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다.

ex) 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제에 자원을 요청한 상황에서 웹 브라우저 - 메모장 - 게임 프로세스 순서대로 자원을 할당하면 교착 상태가 발생하지 않는다.

이때, 웹 브라우저 → 메모장 → 게임이 안전 순서열이 된다.

안전 순서열이 있는 상태를 안전 상태라고 볼 수있다.

안전 순서열대로 프로세스들에 자원을 배분하여 교착 상태가 발생하지 않는 상태를 안전 상태라고 한다.

불안전 상태는 안전 순서열이 없는 상황이다.

시스템이 불안전상태에 놓이면 교착 상태가 발생할 수 있는 위험이 있다.

즉, 안전순서열이 존재하는 상태를 안전 상태, 안전 순서열이 없는 상태를 불안전상태라고 한다.

안전 상태와 불안전 상태, 안전 순서열은 용어의 정의보다 예시를 통해 이해하는것이 더 좋다.

현재 컴퓨터 시스템에 총 12개의 어떠한 자원이 있고, P1, P2, P3 세 개의 프로세스가 실행중이며, 각각 5 2,2개를 할당받아 사용중이라고 가정해보자.

| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P2 | 4 | 2 |
| P3 | 9 | 2 |

할당 가능 자원 : 12

할당한 자원 : 9

남은 자원 : 3

이 상태는 안전 상태이다. P2 → P1 → P3라는 안전 순서열이 있기 때문이다.

P1,P2,P3가 모두 최대로 자원을 요구한 최악의 상황을 가정해보자.

| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P2 | 4 | 2 + 2 |
| P3 | 9 | 2 |

할당 가능 자원 : 12

할당한 자원 : 11

남은 자원 : 1

요구한 4개의 자원을 할당받은 P2는 작업을 끝내고 가지고 있던 자원을 반환한다.

그러면 남은 자원은 5개가 된다.

| 프로세스 | 최대 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 + 5 |
| P3 | 9 | 2 |

할당 가능 자원 : 12

할당한 자원 12

남은 자원 0

P1이 작업을 정상적으로 마치고 자원을 반환하면 이제 P3에 자원을 할당하면 된다.

| 프로세스 | 최대 요구량 | 현재 사용량 |
| --- | --- | --- |
| P3 | 9 | 2 |

할당 가능 자원 : 12

할당한 자원 : 2

남은 자원 : 10

P2 → P1 → P3라는 안전 순서열대로 자원을 배분하면 P1, P2 P3모두 자원을 할당받고 교착 상태 없이 올바르게 작업을 마칠 수 있다.

- 다른 상황을 생각해보자

P3에 먼저 자원을 하나 내주었다고 가정하자.

| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P2 | 4 | 2 |
| P3 | 9 | 3 |

할당 가능 자원 : 12

할당한 자원 : 10

남은 자원 : 2

이 상황은 불안전 상태이다. 즉, 교착 상태가 발생할 위험이 있다.

P1,P2,P3 모두 최대로 자원을 요구한 최악의 상황을 가정해보자.

| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P2 | 4 | 2 + 2 |
| P3 | 9 | 3 |

할당 가능 자원 : 12

할당한 자원 : 12

남은 자원 : 0

| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P3 | 9 | 3 |

할당 가능 자원 : 12

할당한 자원 : 8

남은 자원 : 4

P2작업을 올바르게 끝낸다고 해도, P2 작업 이후 반환된 자원 4개로는 P1의 요구도 P3의 요구도 들어 줄 수 없다.

`P1과 P3는 서로가 보유하고 있는 자원만을 바라보며 무한정 기다릴 수 밖에 없다.`

즉, 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당하면 된다. 즉, 교착 상태 회피 방식은 항시 안전 상태를 유지하도록 자원을 할당하는 방식이라 보면된다.

### 검출 후 회복

자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복하는 방법을 취한다.

검출 후 회복방식에서 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사한다.

그리고 교착 상태가 검출되면 회복한다.

1. 선점을 통한 회복

선점을 통한 회복은 교착상태가 해결될 때 까지 한 프로세스씩 자원을 몰아주는 방식이다.

교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식

1. 프로세스 강제 종료를 통한 회복

프로세스 강제 종료를 통한 회복은 가장 단순하면서 확실하다.

운영체제는 교착 상태에 놓인 프로세스를 모두 강제 종료 할 수도 있다.

그 만큼 프로세스들이 작업 내역을 잃게될 가능성이있다.

운영체제는 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료할 수도 있다.

작업 내역을 잃는 프로세스는 최대한 줄일 수 있지만, 교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드를 야기한다.

드물게 발생하는 잠재적 문제를 무시로 대처하는 방식으로 타조(ostrich algorithm)이 있다.

타조가 문제에 처했을 때 머리를 땅에 묻고 모른체하는 모습에서 따 온 이름이다.

과학자나 수학자 입장에서는 납득할 수 없지만, 문제 발생의 빈도나, 심각성에 따라 최대 효율을 추구하는 엔지니어 입장에서는 때때로 이 방식이 적합하다.
