### 1주차에 한 내용

Tomcat 서버구축 및 War로 빌드해서 배포

Answer Controller ,Entity, Repository, Service ,Dto ,Mapper 구현

Comment Controller ,Entity, Repository, Service ,Dto ,Mapper 구현

### 이번주에 생긴 문제

1. 연관 관계 매핑 오류.

Spring Data JPA에서 배운내용 정리

### @OneToMany

잘못 알고 있었던 내용

@OneToMany의 (mappedBy = “TABLE_NAME”)

mappedBy는 테이블의 이름을 명시해주어야한다고 배웠었다.

하지만, 테이블 이름으로 명시하고 코드를 실행시켜보면 오류가 발생한다.

이는 테이블 이름과 객체의 이름이 일치하고 있던 우연의 상황을 같은 상황이라 착각하고 작성한 예제를 보고 학습하여 발생한 문제였다.

```java
Caused by: org.hibernate.AnnotationException: mappedBy reference an unknown target entity property: com.seb39_pre_014.server.comment.entity.Comment.member in com.seb39_pre_014.server.member.entity.Member.comments
```

JoinColumn(name = “MEMBER_ID”)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/78478f76-2b59-4074-adf8-a16cc1863a1a/Untitled.png)

1. Mapper 오류

Mapper는 객체가 들어갈때, Null인지 아닌지 구분해주는게 정말 중요하다.

Mapper에 붙는 componentModel = “spring” Spring IOC를 사용하기 위해 필요한 옵션이다.

1. Spring Data Jpa 에서 find()메서드를 사용할때, @Transactional(readOnly = true)는 필요한가?

영속성 컨텍스트에 관리를 받지않아, 스냅샷 저장. 변경 감지 수행등을 하지 않아 성능적으로 나아진다.

1. Pageable이 받을 수 있는 파라미터들.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d797b60e-83b4-4484-9144-0e0209bca801/Untitled.png)

이후 Page로 받아온 데이터들.

```json
{
    "data": [
        {
            "boardId": 1,
            "memberId": null,
            "title": "TITLE",
            "content": "CONTENT",
            "recommendCnt": null,
            "answerCnt": null,
            "viewsCnt": null,
            "createAt": null,
            "modifiedAt": null,
            "deletedAt": null,
            "deleted": false
        },
        {
            "boardId": 2,
            "memberId": null,
            "title": "TITLE1",
            "content": "CONTENT1",
            "recommendCnt": null,
            "answerCnt": null,
            "viewsCnt": null,
            "createAt": null,
            "modifiedAt": null,
            "deletedAt": null,
            "deleted": false
        },
        {
            "boardId": 3,
            "memberId": null,
            "title": "TITLE1",
            "content": "CONTENT1",
            "recommendCnt": null,
            "answerCnt": null,
            "viewsCnt": null,
            "createAt": null,
            "modifiedAt": null,
            "deletedAt": null,
            "deleted": false
        }
    ],
    "pageInfo": {
        "page": 1,
        "size": 3,
        "totalElements": 23,
        "totalPages": 8
    }
}
```

전체 23개 중에 3개만 나옴, (Parameter : ?page=1&size=3)

```json
{
    "data": [
        {
            "boardId": 4,
            "memberId": null,
            "title": "TITLE1",
            "content": "CONTENT1",
            "recommendCnt": null,
            "answerCnt": null,
            "viewsCnt": null,
            "createAt": null,
            "modifiedAt": null,
            "deletedAt": null,
            "deleted": false
        },
        {
            "boardId": 5,
            "memberId": null,
            "title": "TITLE1",
            "content": "CONTENT1",
            "recommendCnt": null,
            "answerCnt": null,
            "viewsCnt": null,
            "createAt": null,
            "modifiedAt": null,
            "deletedAt": null,
            "deleted": false
        },
        {
            "boardId": 6,
            "memberId": null,
            "title": "TITLE1",
            "content": "CONTENT1",
            "recommendCnt": null,
            "answerCnt": null,
            "viewsCnt": null,
            "createAt": null,
            "modifiedAt": null,
            "deletedAt": null,
            "deleted": false
        }
    ],
    "pageInfo": {
        "page": 2,
        "size": 3,
        "totalElements": 23,
        "totalPages": 8
    }
}
```

2페이지 , 4~6까지 나옴.

실제 find를 할때는 Page Parameter에 page - 1 이 되어야함.

page의 index는 0부터 시작해야하기 때문.

### ****@MappedSuperclass****

JPA Entity클래스들이 BaseTiem class를 상속할 경우 BaseTime class의 필드인 createdDate, modifiedDate를 인식하게 된다.

### @EventListeners

EntityListeners란 JPA Entity에서 이벤트가 발생할 때마다 특정 로직을 실행시킬 수 있는 어노테이션

예시를 들면, CreatedAt을 가져올때마다, EventListeners 를 통해 호출할 수 있게 되는것이다.

//추론임.

### @CreatedDate

Entity가 생성되어 저장될 때 시간이 자동으로 저장된다.

따로 LocalDateTime.now()를 쓰지 않아도 @CreatedDate 덕분에 자동으로 추가된다.

### @LastModifiedDate

조회한 Entity의 값을 변경할 때 시간이 자동으로 저장된다.

### @EnableJpaAuditing

JPA Auditing 기능을 활성화하기 위한 Annotation이다.

### 2주차에 한 내용

### Board 게시글과 Answer 게시글 1:N 연결하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4df36c2-0b88-4a2b-b1a7-4d108259eedc/Untitled.png)

분명히 answer.getBoard().setBoardId(boardId)로 Board값을 저장해주었는데, 아무리 Postman으로 요청을 날려보아도 돌아오는건 “BoardId” : null 이었다.

- null 값을 반환하는 이유.

연관관계 매핑된 상태에서 Mapstruct는 자동으로 answer객체의 Board객체안에 BoardId를 2번 거쳐서 접근할 수 없었기 때문에 Mapper에 answerPost가 등록되지 않았다.

나중에 Java 8로 리팩토링 해볼것.

```java
@PostMapping("/tutorials/{tutorialId}/comments")
  public ResponseEntity<Comment> createComment(@PathVariable(value = "tutorialId") Long tutorialId,
      @RequestBody Comment commentRequest) {
    Comment comment = tutorialRepository.findById(tutorialId).map(tutorial -> {
      commentRequest.setTutorial(tutorial);
      return commentRepository.save(commentRequest);
    }).orElseThrow(() -> new ResourceNotFoundException("Not found Tutorial with id = " + tutorialId));

    return new ResponseEntity<>(comment, HttpStatus.CREATED);
  }
```

### 문제들

1. Pull Request 문제.

1. Merge 문제.

### Spring Boot Auto Configuration

- Enables Spring Security’s default configuration, which creates a servlet `Filter` as a bean named `springSecurityFilterChain`. This bean is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, and so on) within your application.
- Creates a `UserDetailsService` bean with a username of `user` and a randomly generated password that is logged to the console.
- Registers the `Filter` with a bean named `springSecurityFilterChain` with the Servlet container for every request.

### What is “Principal”

The principal *is* the currently logged in user. However, you retrieve it through the security context which is bound to the current thread and as such it's also bound to the current request and its session.

### FilterChain이란?

`FilterChain`which contains the `Filter`s and `Servlet`that should process the `HttpServletRequest` based on the path of the request URI.

### Servlet이란?

In a Spring MVC application the `Servlet` is an instance of `[DispatcherServlet](https://docs.spring.io/spring-framework/docs/5.3.22/reference/html/web.html#mvc-servlet)`

At most one `Servlet` can handle a single `HttpServletRequest` and `HttpServletResponse`

### Authentication이란?

A라고 주장하는 주체(User, Subject, Principal)이 A가 맞는지 확인하는것.

코드에서의 Authentication은 인증 과정에 사용되는 핵심 객체이다.

ID/Password, JWT, OAuth등 여러 방식으로 인증에 필요한값이 전달되는데 이것을 하나의 인터페이스로 받아 수행하도록 추상화하는 역할의 인터페이스다.

`아이디/패스워드를 사용해 로그인 하는것은 인증에 해당한다.`

### Authorizaiton?

특정 자원에 대한 권한이 있는지 확인하는것.

### Credential이란?

인증 과정 중, 주체가 본일을 인증하기 위해 서버에 제공하는것.

용어가 정확히 무

하나씩 가보자

1. 로그인 요청이 들어온다.
2. 인증에 실패한다. → 인증을 만들어준다.
3. AuthenticationManager로 전달한다. 왜? 그러게 이걸 찾아야한다.

### AuthenticationManager의 기능은 무엇일까?

AuthenticationManager는 스프링 시큐리티 필터들이 인증을 이행하는 방법들이 모인 API다.

반환된 인증은 컨트롤러에 의해 SecurityContextHolder에 지정된다.

만약 스프링 필터들을 통합하지 않고 있다면, SecurityContextHolder를 직접 지정하고 AuthenticationManger는 필요없을 수 있다.

### ProviderManager의 기능은 무엇일까?

AutenticationManager를 구현하는데 주로 사용된다.

PrividerManger는 AuthenticationProvierds의 List로 위임한다.

### AuthenticationProvider란?

다양한 AuthenticationProvider는 ProviderMangaer로 주입될 수 있다.

AuthenticationProvider는 특정한 인증을 행한다.

예를들어, DaoAuthenticationProvider는 username/password을 기반으로한 인증을 제공한다.

반면에 JwtAuthenticationprovider는 JWT 토큰을 기반으로한 인증을 제공을한다.

### SecurityContextHolder

스프링 시큐리티가 누가 인증이 되었는지에 대해 details를 저장하는곳이다.

### SecurityContext

SecurityHolder에 의해 흡수 되었고, 현재 인증되고 유저의 인증을 포함한다.

### Authentication

AuthenticationManager에 넣어질 수 있다. 제공하기 위해
